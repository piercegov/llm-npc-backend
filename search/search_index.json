{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LLM NPC Python SDK","text":"<p>Welcome to the LLM NPC Python SDK documentation! This SDK provides a simple and powerful interface for building intelligent Non-Player Characters (NPCs) using Large Language Models.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udfaf Simple API: Clean, intuitive interface for creating and managing NPCs</li> <li>\ud83d\udee0\ufe0f Tool Decorators: Define game actions with a simple <code>@tool</code> decorator</li> <li>\ud83d\udce6 Type-Safe: Full type hints for better IDE support and error detection</li> <li>\ud83c\udfd7\ufe0f Builders: Convenient builders for surroundings, events, and knowledge graphs</li> <li>\ud83d\udd04 Flexible: Support for both simple and advanced usage patterns</li> <li>\ud83e\udde0 Knowledge Graphs: Give NPCs persistent memory and understanding of relationships</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from llm_npc import NPCClient, tool\n\n# Define game tools with decorators\n@tool(description=\"Make the NPC speak\")\ndef speak(message: str, target: str = None):\n    \"\"\"\n    Args:\n        message: What the NPC should say\n        target: Optional character to address\n    \"\"\"\n    print(f\"NPC says: {message}\")\n\n# Initialize client\nclient = NPCClient(\"http://localhost:8080\")\n\n# Create a session and NPC\nwith client.session(\"my-game-session\") as session:\n    # Register tools\n    session.register_tools([speak])\n\n    # Create an NPC\n    wizard = session.create_npc(\n        name=\"Gandalf\",\n        background=\"A wise wizard with centuries of experience\"\n    )\n\n    # Make the NPC act\n    response = wizard.act(\n        surroundings=[\"Dark cave\", \"Sleeping dragon\", \"Pile of gold\"],\n        events=[\"You hear footsteps behind you\"]\n    )\n\n    print(response.text)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>uv</code> (fast Python package installer):</p> <pre><code># macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Install the SDK from the repository:</p> <pre><code>cd python-sdk\nuv pip install -e .\n</code></pre> <p>For development with testing and linting tools:</p> <pre><code>uv pip install -e \".[dev]\"\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>Running LLM NPC Backend server</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p>:material-clock-fast:{ .lg .middle } Getting Started</p> <p>Install and configure the SDK, create your first NPC</p> <p>:octicons-arrow-right-24: Getting Started</p> </li> <li> <p>:material-book-open-variant:{ .lg .middle } User Guide</p> <p>Learn how to define tools, build context, and work with NPCs</p> <p>:octicons-arrow-right-24: User Guide</p> </li> <li> <p>:material-code-json:{ .lg .middle } API Reference</p> <p>Detailed API documentation for all classes and functions</p> <p>:octicons-arrow-right-24: API Reference</p> </li> <li> <p>:material-application-brackets:{ .lg .middle } Examples</p> <p>Complete working examples to get you started quickly</p> <p>:octicons-arrow-right-24: Examples</p> </li> </ul>"},{"location":"#why-use-this-sdk","title":"Why Use This SDK?","text":"<p>Compare the SDK to manually using the backend API:</p> With SDKWithout SDK (Manual API) <pre><code>from llm_npc import NPCClient, tool, Surroundings\n\n@tool\ndef speak(message: str):\n    \"\"\"Make the NPC speak\"\"\"\n    pass\n\nclient = NPCClient(\"http://localhost:8080\")\n\nwith client.session(\"my-game\") as session:\n    session.register_tools([speak])\n    npc = session.create_npc(\"Gandalf\", \"A wise wizard\")\n\n    surroundings = Surroundings()\n    surroundings.add(\"Cave\", \"A dark cave\")\n\n    response = npc.act(surroundings)\n    print(response.text)\n</code></pre> <pre><code>import requests\n\n# Register tools\ntools_payload = {\n    \"session_id\": \"my-game\",\n    \"tools\": [{\n        \"name\": \"speak\",\n        \"description\": \"Make the NPC speak\",\n        \"parameters\": {\n            \"message\": {\n                \"type\": \"string\",\n                \"description\": \"What to say\",\n                \"required\": True\n            }\n        }\n    }]\n}\nrequests.post(\"http://localhost:8080/tools/register\", json=tools_payload)\n\n# Register NPC\nnpc_payload = {\n    \"name\": \"Gandalf\",\n    \"background_story\": \"A wise wizard\"\n}\nresult = requests.post(\"http://localhost:8080/npc/register\", json=npc_payload).json()\nnpc_id = result['npc_id']\n\n# Act\nact_payload = {\n    \"npc_id\": npc_id,\n    \"session_id\": \"my-game\",\n    \"surroundings\": [{\"name\": \"Cave\", \"description\": \"A dark cave\"}]\n}\nresponse = requests.post(\"http://localhost:8080/npc/act\", json=act_payload).json()\nprint(response.get('llm_response', ''))\n</code></pre> <p>The SDK reduces boilerplate by ~90% and provides type safety, better error handling, and a more intuitive API!</p>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>Repository: GitHub</li> <li>Issues: Report bugs or request features</li> <li>Backend Docs: Main project documentation</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get up and running with the LLM NPC Python SDK in minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ol> <li>Python 3.8 or higher installed</li> <li>LLM NPC Backend running (see backend setup)</li> <li>pip package manager</li> </ol>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#install-uv","title":"Install uv","text":"<p>First, install <code>uv</code> - a fast Python package installer:</p> <pre><code># macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# Or with pip\npip install uv\n</code></pre>"},{"location":"getting-started/#from-source","title":"From Source","text":"<p>Clone the repository and install the SDK:</p> <pre><code># Clone the repository\ngit clone https://github.com/piercegov/llm-npc-backend.git\ncd llm-npc-backend/python-sdk\n\n# Install in development mode\nuv pip install -e .\n</code></pre>"},{"location":"getting-started/#with-development-tools","title":"With Development Tools","text":"<p>If you're planning to contribute or modify the SDK:</p> <pre><code>uv pip install -e \".[dev]\"\n</code></pre> <p>This installs additional tools like pytest, black, and mypy.</p>"},{"location":"getting-started/#starting-the-backend","title":"Starting the Backend","text":"<p>The SDK communicates with the LLM NPC Backend server. Make sure it's running:</p> <pre><code># In the repository root\n./backend --http\n\n# Or build and run\ngo build ./cmd/backend/...\n./backend --http\n</code></pre> <p>The server will start on <code>http://localhost:8080</code> by default.</p> <p>Health Check</p> <p>You can verify the backend is running: <pre><code>curl http://localhost:8080/health\n# Should return: pong\n</code></pre></p>"},{"location":"getting-started/#your-first-npc","title":"Your First NPC","text":"<p>Let's create a simple NPC that can speak and move.</p>"},{"location":"getting-started/#step-1-define-tools","title":"Step 1: Define Tools","text":"<p>Tools are actions that NPCs can perform. Use the <code>@tool</code> decorator:</p> <pre><code>from llm_npc import tool\n\n@tool(description=\"Make the NPC speak dialogue\")\ndef speak(message: str, target: str = None):\n    \"\"\"\n    Args:\n        message: What the NPC should say\n        target: Optional character to address\n    \"\"\"\n    print(f\"\ud83d\udde3\ufe0f  {message}\")\n    if target:\n        print(f\"   (to {target})\")\n\n@tool(description=\"Move to a new location\")\ndef move_to(location: str):\n    \"\"\"\n    Args:\n        location: Where to move\n    \"\"\"\n    print(f\"\ud83d\udeb6 Moving to {location}\")\n</code></pre>"},{"location":"getting-started/#step-2-create-a-client-and-session","title":"Step 2: Create a Client and Session","text":"<pre><code>from llm_npc import NPCClient\n\n# Initialize the client\nclient = NPCClient(\"http://localhost:8080\")\n\n# Check if backend is running\nif not client.health_check():\n    print(\"\u274c Backend not running!\")\n    exit(1)\n\nprint(\"\u2705 Connected to backend\")\n</code></pre>"},{"location":"getting-started/#step-3-register-tools-and-create-an-npc","title":"Step 3: Register Tools and Create an NPC","text":"<pre><code># Create a session for your game\nwith client.session(\"my-first-game\") as session:\n    # Register your tools\n    session.register_tools([speak, move_to])\n    print(\"\u2705 Tools registered\")\n\n    # Create an NPC\n    guard = session.create_npc(\n        name=\"Sir Reginald\",\n        background=\"A loyal knight who guards the castle gate. \"\n                   \"He's friendly to visitors but wary of suspicious characters.\"\n    )\n    print(f\"\u2705 Created NPC: {guard}\")\n</code></pre>"},{"location":"getting-started/#step-4-make-the-npc-act","title":"Step 4: Make the NPC Act","text":"<pre><code>    # Define what the NPC can see/experience\n    response = guard.act(\n        surroundings=[\n            \"Castle Gate - A large wooden gate with iron reinforcements\",\n            \"Traveler - A hooded figure approaching the gate\",\n            \"Sunset - The sun is setting behind the mountains\"\n        ],\n        events=[\n            \"A hooded traveler is approaching the gate\"\n        ]\n    )\n\n    # Check the response\n    if response.success:\n        print(f\"\\n\ud83d\udcad NPC Thought: {response.text}\")\n\n        # See what actions the NPC took\n        if response.tools_used:\n            print(\"\\n\ud83d\udee0\ufe0f  Actions taken:\")\n            for tool in response.tools_used:\n                print(f\"  - {tool.name}: {tool.args}\")\n    else:\n        print(f\"\u274c Error: {response.error}\")\n</code></pre>"},{"location":"getting-started/#complete-example","title":"Complete Example","text":"<p>Here's the complete code:</p> <pre><code>from llm_npc import NPCClient, tool\n\n# Define tools\n@tool(description=\"Make the NPC speak dialogue\")\ndef speak(message: str, target: str = None):\n    \"\"\"\n    Args:\n        message: What the NPC should say\n        target: Optional character to address\n    \"\"\"\n    print(f\"\ud83d\udde3\ufe0f  {message}\")\n\n@tool(description=\"Move to a new location\")\ndef move_to(location: str):\n    \"\"\"\n    Args:\n        location: Where to move\n    \"\"\"\n    print(f\"\ud83d\udeb6 Moving to {location}\")\n\n# Initialize client\nclient = NPCClient(\"http://localhost:8080\")\n\nif not client.health_check():\n    print(\"\u274c Backend not running!\")\n    exit(1)\n\n# Create session and NPC\nwith client.session(\"my-first-game\") as session:\n    session.register_tools([speak, move_to])\n\n    guard = session.create_npc(\n        name=\"Sir Reginald\",\n        background=\"A loyal knight who guards the castle gate\"\n    )\n\n    # Make the NPC act\n    response = guard.act(\n        surroundings=[\n            \"Castle Gate\",\n            \"Traveler approaching\",\n            \"Sunset\"\n        ],\n        events=[\"A hooded traveler approaches\"]\n    )\n\n    if response.success:\n        print(f\"\ud83d\udcad {response.text}\")\n        for tool in response.tools_used:\n            print(f\"\ud83d\udee0\ufe0f  {tool.name}: {tool.args}\")\n</code></pre>"},{"location":"getting-started/#running-the-example","title":"Running the Example","text":"<p>Save the code to <code>first_npc.py</code> and run:</p> <pre><code>python first_npc.py\n</code></pre> <p>You should see output like:</p> <pre><code>\u2705 Connected to backend\n\u2705 Tools registered\n\u2705 Created NPC: NPC(id=abc-123, name=Sir Reginald)\n\ud83d\udcad A traveler is approaching. I should greet them and inquire about their business.\n\ud83d\udee0\ufe0f  speak: {'message': 'Halt! State your business at the castle.', 'target': 'Traveler'}\n\ud83d\udde3\ufe0f  Halt! State your business at the castle.\n   (to Traveler)\n</code></pre>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<p>Now that you have your first NPC working, explore more advanced features:</p> <ul> <li>Defining Tools - Learn about parameter types, docstrings, and advanced tool patterns</li> <li>Building Context - Use builders for more structured surroundings and events</li> <li>Knowledge Graphs - Give your NPCs memory and understanding of relationships</li> <li>Working with Responses - Parse NPC responses and handle multi-round inference</li> </ul>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#backend-connection-issues","title":"Backend Connection Issues","text":"<p>If you get connection errors:</p> <pre><code>from llm_npc.exceptions import BackendConnectionError\n\ntry:\n    client.health_check()\nexcept BackendConnectionError:\n    print(\"Cannot connect to backend. Is it running?\")\n</code></pre>"},{"location":"getting-started/#empty-responses","title":"Empty Responses","text":"<p>If your NPC produces empty responses:</p> <ul> <li>Try a larger model: Small models like <code>qwen3:1.7b</code> may not perform well</li> <li>Check backend logs: Look for LLM errors</li> <li>Simplify the scenario: Start with simpler surroundings</li> </ul> <pre><code>response = npc.act([\"Simple room\", \"Door\"])\n</code></pre>"},{"location":"getting-started/#tool-registration-errors","title":"Tool Registration Errors","text":"<p>Make sure your functions are decorated:</p> <pre><code># \u2705 Correct\n@tool\ndef my_action():\n    pass\n\n# \u274c Wrong - missing decorator\ndef my_action():\n    pass\n</code></pre>"},{"location":"getting-started/#configuration","title":"Configuration","text":""},{"location":"getting-started/#custom-backend-url","title":"Custom Backend URL","text":"<pre><code>client = NPCClient(\"http://your-server:8080\")\n</code></pre>"},{"location":"getting-started/#using-pip-instead-of-uv","title":"Using pip Instead of uv","text":"<p>If you prefer using <code>pip</code>, simply replace <code>uv pip</code> with <code>pip</code>:</p> <pre><code>pip install -e .\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"<p>The backend can be configured via environment variables. See the backend documentation for details.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Ready to dive deeper? Check out the User Guide for comprehensive tutorials on all SDK features!</p>"},{"location":"advanced/best-practices/","title":"Best Practices","text":"<p>Production-ready patterns and tips for building robust NPC systems.</p>"},{"location":"advanced/best-practices/#tool-design","title":"Tool Design","text":""},{"location":"advanced/best-practices/#keep-tools-atomic","title":"Keep Tools Atomic","text":"<p>Each tool should do one thing:</p> <pre><code># \u2705 Good - single responsibility\n@tool\ndef open_door(door: str):\n    \"\"\"Open a specific door\"\"\"\n    pass\n\n@tool\ndef walk_through_door(door: str):\n    \"\"\"Walk through a door\"\"\"\n    pass\n\n# \u274c Bad - doing too much\n@tool\ndef open_and_walk_through_door(door: str):\n    \"\"\"Open a door and walk through it\"\"\"\n    pass\n</code></pre>"},{"location":"advanced/best-practices/#clear-tool-descriptions","title":"Clear Tool Descriptions","text":"<p>Write descriptions that tell NPCs when to use the tool:</p> <pre><code># \u2705 Good\n@tool(description=\"Speak dialogue when you want to communicate with someone nearby\")\ndef speak(message: str):\n    pass\n\n# \u274c Bad\n@tool(description=\"A tool for speech\")\ndef speak(message: str):\n    pass\n</code></pre>"},{"location":"advanced/best-practices/#document-all-parameters","title":"Document All Parameters","text":"<pre><code>@tool\ndef complex_action(target: str, method: str, power: int = 5):\n    \"\"\"\n    Perform a complex action on a target.\n\n    Args:\n        target: Who or what to target\n        method: How to perform the action (attack, defend, assist)\n        power: Intensity level from 1-10 (default: 5)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"advanced/best-practices/#npc-background-stories","title":"NPC Background Stories","text":""},{"location":"advanced/best-practices/#be-specific","title":"Be Specific","text":"<pre><code># \u2705 Good - detailed personality\nguard = session.create_npc(\n    \"Captain Sarah Chen\",\n    \"A 15-year veteran of the city guard with a reputation for fairness \"\n    \"but zero tolerance for crime. She's methodical, observant, and \"\n    \"slightly paranoid after a recent assassination attempt. \"\n    \"Currently investigating a theft ring operating in the market district. \"\n    \"She trusts her instincts and isn't easily fooled.\"\n)\n\n# \u274c Bad - too vague\nguard = session.create_npc(\n    \"Guard\",\n    \"A guard who guards things\"\n)\n</code></pre>"},{"location":"advanced/best-practices/#include-current-context","title":"Include Current Context","text":"<pre><code>merchant = session.create_npc(\n    \"Tobias the Merchant\",\n    \"A middle-aged merchant who sells rare artifacts. He's usually jovial \"\n    \"and loves to haggle, but he's been nervous lately because he owes money \"\n    \"to the Thieves' Guild and the payment is overdue. He's desperate for a \"\n    \"big sale and might take risks he normally wouldn't.\"\n)\n</code></pre>"},{"location":"advanced/best-practices/#context-management","title":"Context Management","text":""},{"location":"advanced/best-practices/#scope-appropriately","title":"Scope Appropriately","text":"<p>Keep context focused on what matters:</p> <pre><code># \u2705 Good - focused, relevant details\nsurroundings = Surroundings()\nsurroundings.add(\"Market Square\", \"Busy marketplace with 20+ vendors\")\nsurroundings.add(\"Suspicious Man\", \"Hooded figure watching the jewelry stall\")\nsurroundings.add(\"Jewelry Stall\", \"Unguarded stall with expensive items displayed\")\n\n# \u274c Bad - too much irrelevant detail\nsurroundings = Surroundings()\nfor i in range(50):  # Don't overwhelm the LLM\n    surroundings.add(f\"Random Detail {i}\", \"...\")\n</code></pre>"},{"location":"advanced/best-practices/#dynamic-context","title":"Dynamic Context","text":"<p>Build context from game state:</p> <pre><code>class ContextManager:\n    def __init__(self, game_state):\n        self.game_state = game_state\n\n    def get_npc_surroundings(self, npc_location):\n        \"\"\"Build surroundings based on NPC location\"\"\"\n        surroundings = Surroundings()\n\n        # Add location\n        location = self.game_state.get_location(npc_location)\n        surroundings.add(location.name, location.description)\n\n        # Add NPCs at same location\n        for other_npc in self.game_state.get_npcs_at(npc_location):\n            surroundings.add(other_npc.name, other_npc.appearance)\n\n        # Add relevant objects\n        for obj in self.game_state.get_objects_at(npc_location):\n            surroundings.add(obj.name, obj.description)\n\n        return surroundings\n</code></pre>"},{"location":"advanced/best-practices/#response-processing","title":"Response Processing","text":""},{"location":"advanced/best-practices/#always-validate","title":"Always Validate","text":"<pre><code>def process_npc_action(npc, response):\n    \"\"\"Process NPC action with validation\"\"\"\n    if not response or not response.success:\n        logger.warning(f\"NPC {npc.name} action failed\")\n        return False\n\n    # Process tools\n    for tool in response.tools_used:\n        if not tool.success:\n            logger.warning(f\"Tool {tool.name} failed for {npc.name}\")\n            continue\n\n        # Handle each tool type\n        if tool.name == \"speak\":\n            handle_speech(npc, tool.args)\n        elif tool.name == \"move_to\":\n            handle_movement(npc, tool.args)\n\n    return True\n</code></pre>"},{"location":"advanced/best-practices/#cache-when-appropriate","title":"Cache When Appropriate","text":"<pre><code>class NPCResponseCache:\n    def __init__(self, ttl=300):  # 5 minute TTL\n        self.cache = {}\n        self.ttl = ttl\n\n    def get_cache_key(self, npc_id, surroundings, events):\n        \"\"\"Create cache key from inputs\"\"\"\n        import hashlib\n        import json\n\n        data = {\n            \"npc\": npc_id,\n            \"surroundings\": str(surroundings),\n            \"events\": str(events)\n        }\n        return hashlib.md5(json.dumps(data).encode()).hexdigest()\n\n    def get(self, npc_id, surroundings, events):\n        \"\"\"Get cached response if valid\"\"\"\n        key = self.get_cache_key(npc_id, surroundings, events)\n        if key in self.cache:\n            cached, timestamp = self.cache[key]\n            if time.time() - timestamp &lt; self.ttl:\n                return cached\n        return None\n\n    def set(self, npc_id, surroundings, events, response):\n        \"\"\"Cache a response\"\"\"\n        key = self.get_cache_key(npc_id, surroundings, events)\n        self.cache[key] = (response, time.time())\n</code></pre>"},{"location":"advanced/best-practices/#knowledge-graphs","title":"Knowledge Graphs","text":""},{"location":"advanced/best-practices/#keep-them-focused","title":"Keep Them Focused","text":"<pre><code>def build_npc_knowledge_graph(npc, game_state):\n    \"\"\"Build knowledge graph with only relevant information\"\"\"\n    kg = KnowledgeGraph()\n\n    # Only add entities the NPC knows about\n    for entity_id in npc.known_entities:\n        entity = game_state.get_entity(entity_id)\n        kg.add_node(entity_id, **entity.to_dict())\n\n    # Only add relationships the NPC is aware of\n    for rel in npc.known_relationships:\n        kg.add_edge(rel.source, rel.target, relationship=rel.type)\n\n    return kg\n</code></pre>"},{"location":"advanced/best-practices/#update-incrementally","title":"Update Incrementally","text":"<pre><code>class NPCKnowledgeManager:\n    def __init__(self):\n        self.npc_knowledge = {}  # npc_id -&gt; KnowledgeGraph\n\n    def update_knowledge(self, npc_id, new_info):\n        \"\"\"Incrementally update NPC knowledge\"\"\"\n        if npc_id not in self.npc_knowledge:\n            self.npc_knowledge[npc_id] = KnowledgeGraph()\n\n        kg = self.npc_knowledge[npc_id]\n\n        # Add new entities\n        for entity in new_info.get(\"entities\", []):\n            kg.add_node(entity[\"id\"], **entity[\"data\"])\n\n        # Add new relationships\n        for rel in new_info.get(\"relationships\", []):\n            kg.add_edge(rel[\"source\"], rel[\"target\"], **rel[\"data\"])\n\n    def get_knowledge(self, npc_id):\n        \"\"\"Get NPC's current knowledge graph\"\"\"\n        return self.npc_knowledge.get(npc_id, KnowledgeGraph())\n</code></pre>"},{"location":"advanced/best-practices/#performance","title":"Performance","text":""},{"location":"advanced/best-practices/#batch-operations","title":"Batch Operations","text":"<pre><code>def process_multiple_npcs_parallel(npcs, shared_surroundings, shared_events):\n    \"\"\"Process multiple NPCs in parallel\"\"\"\n    import concurrent.futures\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        futures = {\n            executor.submit(npc.act, shared_surroundings, shared_events): npc\n            for npc in npcs\n        }\n\n        results = {}\n        for future in concurrent.futures.as_completed(futures):\n            npc = futures[future]\n            try:\n                response = future.result(timeout=30)\n                results[npc.name] = response\n            except Exception as e:\n                logger.error(f\"Error processing {npc.name}: {e}\")\n                results[npc.name] = None\n\n        return results\n</code></pre>"},{"location":"advanced/best-practices/#reuse-sessions","title":"Reuse Sessions","text":"<pre><code>class GameSessionManager:\n    def __init__(self, client):\n        self.client = client\n        self.session = None\n\n    def get_session(self):\n        \"\"\"Get or create session\"\"\"\n        if not self.session:\n            self.session = self.client.session(\"game-main\")\n            self.session.register_tools(self.get_all_tools())\n        return self.session\n\n    def get_all_tools(self):\n        \"\"\"Get all game tools\"\"\"\n        return [speak, move_to, attack, defend, use_item]\n</code></pre>"},{"location":"advanced/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"advanced/best-practices/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>def npc_act_safe(npc, surroundings, events):\n    \"\"\"NPC action with graceful degradation\"\"\"\n    try:\n        response = npc.act(surroundings, events)\n        if response.success:\n            return response\n    except Exception as e:\n        logger.error(f\"NPC action failed: {e}\")\n\n    # Fallback: simple scripted behavior\n    return create_fallback_response(npc)\n\ndef create_fallback_response(npc):\n    \"\"\"Create a simple scripted response\"\"\"\n    from llm_npc.models import Response\n\n    # Use NPC's background to determine fallback behavior\n    if \"guard\" in npc.background.lower():\n        text = \"The guard remains watchful and alert.\"\n    elif \"merchant\" in npc.background.lower():\n        text = \"The merchant tends to their goods.\"\n    else:\n        text = f\"{npc.name} continues their activities.\"\n\n    return Response(\n        success=True,\n        text=text,\n        rounds=[],\n        tools_used=[],\n        raw_data={}\n    )\n</code></pre>"},{"location":"advanced/best-practices/#testing","title":"Testing","text":""},{"location":"advanced/best-practices/#unit-test-tools","title":"Unit Test Tools","text":"<pre><code>from llm_npc.decorators import get_tool_metadata\n\ndef test_tool_metadata():\n    \"\"\"Test tool metadata extraction\"\"\"\n    @tool\n    def test_action(param: str, count: int = 5):\n        \"\"\"Test action\"\"\"\n        pass\n\n    metadata = get_tool_metadata(test_action)\n    assert metadata[\"name\"] == \"test_action\"\n    assert metadata[\"description\"] == \"Test action\"\n    assert \"param\" in metadata[\"parameters\"]\n    assert metadata[\"parameters\"][\"param\"][\"type\"] == \"string\"\n    assert metadata[\"parameters\"][\"param\"][\"required\"] == True\n    assert metadata[\"parameters\"][\"count\"][\"type\"] == \"integer\"\n    assert metadata[\"parameters\"][\"count\"][\"required\"] == False\n</code></pre>"},{"location":"advanced/best-practices/#integration-test","title":"Integration Test","text":"<pre><code>def test_npc_integration():\n    \"\"\"Test complete NPC flow\"\"\"\n    from llm_npc import NPCClient, tool, Surroundings\n\n    @tool\n    def speak(message: str):\n        pass\n\n    client = NPCClient(\"http://localhost:8080\")\n\n    # Skip if backend not running\n    if not client.health_check():\n        pytest.skip(\"Backend not running\")\n\n    with client.session(\"test-session\") as session:\n        session.register_tools([speak])\n        npc = session.create_npc(\"Test NPC\", \"A test character\")\n\n        surroundings = Surroundings()\n        surroundings.add(\"Room\", \"A test room\")\n\n        response = npc.act(surroundings)\n\n        assert response is not None\n        assert response.success or response.error is not None\n</code></pre>"},{"location":"advanced/best-practices/#monitoring","title":"Monitoring","text":""},{"location":"advanced/best-practices/#track-metrics","title":"Track Metrics","text":"<pre><code>class NPCMetrics:\n    def __init__(self):\n        self.action_count = 0\n        self.success_count = 0\n        self.failure_count = 0\n        self.total_duration = 0\n\n    def record_action(self, response, duration):\n        \"\"\"Record action metrics\"\"\"\n        self.action_count += 1\n        self.total_duration += duration\n\n        if response and response.success:\n            self.success_count += 1\n        else:\n            self.failure_count += 1\n\n    def get_stats(self):\n        \"\"\"Get statistics\"\"\"\n        return {\n            \"total_actions\": self.action_count,\n            \"success_rate\": self.success_count / max(self.action_count, 1),\n            \"avg_duration\": self.total_duration / max(self.action_count, 1)\n        }\n\n# Usage\nmetrics = NPCMetrics()\n\nstart = time.time()\nresponse = npc.act(surroundings, events)\nduration = time.time() - start\n\nmetrics.record_action(response, duration)\n</code></pre>"},{"location":"advanced/best-practices/#see-also","title":"See Also","text":"<ul> <li>Error Handling</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"advanced/error-handling/","title":"Error Handling","text":"<p>Robust error handling ensures your game remains stable even when the backend or LLM encounters issues.</p>"},{"location":"advanced/error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All SDK exceptions inherit from <code>LLMNPCError</code>:</p> <pre><code>LLMNPCError (base)\n\u251c\u2500\u2500 BackendConnectionError    # Cannot connect to backend\n\u251c\u2500\u2500 BackendError              # Backend returned an error\n\u251c\u2500\u2500 NPCNotFoundError          # NPC doesn't exist\n\u251c\u2500\u2500 SessionError              # Session-related errors\n\u2514\u2500\u2500 ToolRegistrationError     # Tool registration failed\n</code></pre>"},{"location":"advanced/error-handling/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"advanced/error-handling/#1-backend-not-running","title":"1. Backend Not Running","text":"<pre><code>from llm_npc import NPCClient\nfrom llm_npc.exceptions import BackendConnectionError\n\nclient = NPCClient(\"http://localhost:8080\")\n\ntry:\n    if not client.health_check():\n        print(\"Backend is not responding\")\nexcept BackendConnectionError:\n    print(\"Cannot connect to backend\")\n    print(\"Start it with: ./backend --http\")\n</code></pre>"},{"location":"advanced/error-handling/#2-llm-timeout","title":"2. LLM Timeout","text":"<pre><code>from llm_npc.exceptions import BackendError\n\ntry:\n    response = npc.act(surroundings, events)\nexcept BackendError as e:\n    if \"timeout\" in str(e).lower():\n        print(\"LLM took too long to respond\")\n        print(\"Try: smaller context, faster model, or increase timeout\")\n</code></pre>"},{"location":"advanced/error-handling/#3-tool-registration-failures","title":"3. Tool Registration Failures","text":"<pre><code>from llm_npc.exceptions import ToolRegistrationError\n\ndef not_a_tool():\n    \"\"\"Forgot the @tool decorator\"\"\"\n    pass\n\ntry:\n    session.register_tools([not_a_tool])\nexcept ToolRegistrationError as e:\n    print(f\"Tool registration failed: {e}\")\n    # Fix: Add @tool decorator\n</code></pre>"},{"location":"advanced/error-handling/#4-npc-not-found","title":"4. NPC Not Found","text":"<pre><code>from llm_npc.exceptions import NPCNotFoundError\n\ntry:\n    client.delete_npc(\"invalid-id\")\nexcept NPCNotFoundError:\n    print(\"NPC doesn't exist\")\n</code></pre>"},{"location":"advanced/error-handling/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>from llm_npc import NPCClient, tool\nfrom llm_npc.exceptions import (\n    BackendConnectionError,\n    BackendError,\n    ToolRegistrationError,\n    LLMNPCError\n)\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@tool\ndef speak(message: str):\n    \"\"\"Make NPC speak\"\"\"\n    pass\n\ndef main():\n    try:\n        # Initialize\n        client = NPCClient(\"http://localhost:8080\")\n\n        # Health check with timeout handling\n        try:\n            if not client.health_check():\n                logger.error(\"Backend health check failed\")\n                return\n        except BackendConnectionError as e:\n            logger.error(f\"Cannot connect to backend: {e}\")\n            logger.info(\"Make sure backend is running: ./backend --http\")\n            return\n\n        # Create session\n        with client.session(\"game\") as session:\n            # Register tools\n            try:\n                session.register_tools([speak])\n            except ToolRegistrationError as e:\n                logger.error(f\"Tool registration failed: {e}\")\n                return\n\n            # Create NPC\n            try:\n                npc = session.create_npc(\n                    \"Guard\",\n                    \"A city guard\"\n                )\n            except BackendError as e:\n                logger.error(f\"Failed to create NPC: {e}\")\n                return\n\n            # Make NPC act\n            try:\n                response = npc.act(\n                    [\"Town square\"],\n                    [\"A stranger approaches\"]\n                )\n\n                if response.success:\n                    logger.info(f\"NPC response: {response.text}\")\n                else:\n                    logger.warning(f\"NPC action failed: {response.error}\")\n\n            except BackendError as e:\n                logger.error(f\"Backend error during action: {e}\")\n                if hasattr(e, 'status_code'):\n                    if e.status_code == 503:\n                        logger.error(\"LLM service unavailable\")\n                    elif e.status_code == 504:\n                        logger.error(\"LLM request timed out\")\n                    elif e.status_code == 429:\n                        logger.error(\"Rate limit exceeded\")\n\n    except LLMNPCError as e:\n        logger.error(f\"SDK error: {e}\")\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\", exc_info=True)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"advanced/error-handling/#retry-logic","title":"Retry Logic","text":"<p>Implement retry logic for transient errors:</p> <pre><code>import time\nfrom llm_npc.exceptions import BackendError\n\ndef npc_act_with_retry(npc, surroundings, events, max_retries=3, delay=1.0):\n    \"\"\"Make NPC act with automatic retries\"\"\"\n    for attempt in range(max_retries):\n        try:\n            response = npc.act(surroundings, events)\n\n            if response.success:\n                return response\n            else:\n                error = response.error or \"Unknown error\"\n\n                # Check if error is retryable\n                if \"timeout\" in error.lower() or \"unavailable\" in error.lower():\n                    if attempt &lt; max_retries - 1:\n                        print(f\"Attempt {attempt + 1} failed, retrying...\")\n                        time.sleep(delay * (attempt + 1))  # Exponential backoff\n                        continue\n\n                # Non-retryable error\n                return response\n\n        except BackendError as e:\n            if \"timeout\" in str(e).lower() and attempt &lt; max_retries - 1:\n                print(f\"Timeout on attempt {attempt + 1}, retrying...\")\n                time.sleep(delay * (attempt + 1))\n                continue\n            raise\n\n    return None  # All retries failed\n\n# Usage\nresponse = npc_act_with_retry(npc, surroundings, events)\nif response:\n    print(response.text)\nelse:\n    print(\"Failed after all retries\")\n</code></pre>"},{"location":"advanced/error-handling/#fallback-behavior","title":"Fallback Behavior","text":"<p>Provide fallback when LLM fails:</p> <pre><code>def npc_act_with_fallback(npc, surroundings, events, fallback_action=None):\n    \"\"\"Make NPC act with fallback behavior\"\"\"\n    try:\n        response = npc.act(surroundings, events)\n\n        if response.success:\n            return response\n        else:\n            print(f\"NPC action failed: {response.error}\")\n            if fallback_action:\n                return fallback_action()\n\n    except BackendError as e:\n        print(f\"Backend error: {e}\")\n        if fallback_action:\n            return fallback_action()\n\n    return None\n\n# Usage with fallback\ndef guard_fallback():\n    \"\"\"Default guard behavior when LLM fails\"\"\"\n    from llm_npc.models import Response, ToolCall, Round\n\n    # Create a simple fallback response\n    return Response(\n        success=True,\n        text=\"The guard stands alert, watching carefully.\",\n        rounds=[],\n        tools_used=[],\n        raw_data={}\n    )\n\nresponse = npc_act_with_fallback(guard, surroundings, events, guard_fallback)\n</code></pre>"},{"location":"advanced/error-handling/#logging","title":"Logging","text":"<p>Set up proper logging:</p> <pre><code>import logging\nfrom llm_npc import NPCClient\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('npc_game.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\n# Use in your code\ntry:\n    response = npc.act(surroundings)\n    logger.info(f\"NPC {npc.name} acted successfully\")\nexcept Exception as e:\n    logger.error(f\"Error with NPC {npc.name}: {e}\", exc_info=True)\n</code></pre>"},{"location":"advanced/error-handling/#validation","title":"Validation","text":"<p>Validate responses before using them:</p> <pre><code>def validate_response(response):\n    \"\"\"Validate NPC response quality\"\"\"\n    if not response:\n        return False, \"No response\"\n\n    if not response.success:\n        return False, f\"Failed: {response.error}\"\n\n    # Check for empty response\n    if not response.text and not response.tools_used:\n        return False, \"Empty response (model may be too small)\"\n\n    # Check tool success\n    failed_tools = [t for t in response.tools_used if not t.success]\n    if failed_tools:\n        return False, f\"Tools failed: {[t.name for t in failed_tools]}\"\n\n    return True, \"Valid\"\n\n# Usage\nresponse = npc.act(surroundings, events)\nis_valid, message = validate_response(response)\n\nif is_valid:\n    print(response.text)\nelse:\n    print(f\"Invalid response: {message}\")\n</code></pre>"},{"location":"advanced/error-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Always catch specific exceptions before generic ones</li> <li>Log errors for debugging</li> <li>Provide user feedback for connection issues</li> <li>Implement retries for transient errors</li> <li>Have fallback behavior for critical NPCs</li> <li>Validate responses before using them</li> <li>Use timeouts to prevent hanging</li> <li>Monitor error rates in production</li> </ol>"},{"location":"advanced/error-handling/#see-also","title":"See Also","text":"<ul> <li>Exceptions API Reference</li> <li>Best Practices</li> <li>Client API</li> </ul>"},{"location":"api/client/","title":"Client API Reference","text":"<p>The client module provides the main interface for interacting with the LLM NPC Backend.</p>"},{"location":"api/client/#npcclient","title":"NPCClient","text":""},{"location":"api/client/#llm_npc.client.NPCClient","title":"NPCClient","text":"<pre><code>NPCClient(base_url: str = 'http://localhost:8080')\n</code></pre> <p>Main client for interacting with the LLM NPC Backend.</p> Usage <p>client = NPCClient(\"http://localhost:8080\")</p> <p>with client.session(\"my-game-session\") as session:     npc = session.create_npc(\"Gandalf\", \"A wise wizard\")     response = npc.act(surroundings=[\"Dark cave\", \"Dragon\"])</p> <p>Initialize the NPC client.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL of the backend server</p> <code>'http://localhost:8080'</code>"},{"location":"api/client/#llm_npc.client.NPCClient.health_check","title":"health_check","text":"<pre><code>health_check() -&gt; bool\n</code></pre> <p>Check if the backend is running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if backend is healthy, False otherwise</p>"},{"location":"api/client/#llm_npc.client.NPCClient.session","title":"session","text":"<pre><code>session(session_id: str) -&gt; Session\n</code></pre> <p>Create a new session for managing tools and NPCs.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Unique identifier for this game session</p> required <p>Returns:</p> Type Description <code>Session</code> <p>A Session instance</p>"},{"location":"api/client/#llm_npc.client.NPCClient.list_npcs","title":"list_npcs","text":"<pre><code>list_npcs() -&gt; Dict[str, Any]\n</code></pre> <p>List all registered NPCs.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with 'count' and 'npcs' keys</p>"},{"location":"api/client/#llm_npc.client.NPCClient.delete_npc","title":"delete_npc","text":"<pre><code>delete_npc(npc_id: str) -&gt; bool\n</code></pre> <p>Delete an NPC.</p> <p>Parameters:</p> Name Type Description Default <code>npc_id</code> <code>str</code> <p>ID of the NPC to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/#session","title":"Session","text":""},{"location":"api/client/#llm_npc.client.Session","title":"Session","text":"<pre><code>Session(client: NPCClient, session_id: str)\n</code></pre> <p>Manages a game session with tools and NPCs.</p> Can be used as a context manager <p>with client.session(\"my-session\") as session:     session.register_tools([...])     npc = session.create_npc(...)</p> <p>Initialize a session.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NPCClient</code> <p>The NPCClient instance</p> required <code>session_id</code> <code>str</code> <p>Unique identifier for this session</p> required"},{"location":"api/client/#llm_npc.client.Session.register_tools","title":"register_tools","text":"<pre><code>register_tools(tools: List[Callable]) -&gt; Session\n</code></pre> <p>Register game-specific tools for NPCs to use.</p> <p>Parameters:</p> Name Type Description Default <code>tools</code> <code>List[Callable]</code> <p>List of functions decorated with @tool</p> required <p>Returns:</p> Type Description <code>Session</code> <p>Self for method chaining</p> <p>Raises:</p> Type Description <code>ToolRegistrationError</code> <p>If registration fails</p>"},{"location":"api/client/#llm_npc.client.Session.create_npc","title":"create_npc","text":"<pre><code>create_npc(name: str, background: str) -&gt; NPC\n</code></pre> <p>Create a new NPC.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the NPC</p> required <code>background</code> <code>str</code> <p>Background story/description</p> required <p>Returns:</p> Type Description <code>NPC</code> <p>An NPC instance</p> <p>Raises:</p> Type Description <code>BackendError</code> <p>If NPC creation fails</p>"},{"location":"api/client/#npc","title":"NPC","text":""},{"location":"api/client/#llm_npc.client.NPC","title":"NPC","text":"<pre><code>NPC(client: NPCClient, session: Session, npc_id: str, name: str, background: str)\n</code></pre> <p>Represents an NPC that can perform actions.</p> Usage <p>response = npc.act(     surroundings=[\"Forest\", \"Sword on ground\"],     events=[\"You found a weapon\"] )</p> <p>Initialize an NPC instance.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NPCClient</code> <p>The NPCClient instance</p> required <code>session</code> <code>Session</code> <p>The Session this NPC belongs to</p> required <code>npc_id</code> <code>str</code> <p>Backend NPC ID</p> required <code>name</code> <code>str</code> <p>NPC name</p> required <code>background</code> <code>str</code> <p>NPC background story</p> required"},{"location":"api/client/#llm_npc.client.NPC.act","title":"act","text":"<pre><code>act(surroundings: Union[List[str], List[Dict[str, str]], List[Surrounding], Surroundings, ContextBuilder], events: Optional[Union[List[str], List[Dict[str, str]], List[Event]]] = None, knowledge_graph: Optional[Union[KnowledgeGraph, Dict]] = None) -&gt; Response\n</code></pre> <p>Execute an action/tick for this NPC.</p> <p>Parameters:</p> Name Type Description Default <code>surroundings</code> <code>Union[List[str], List[Dict[str, str]], List[Surrounding], Surroundings, ContextBuilder]</code> <p>What the NPC can see/interact with. Can be: - Simple list of strings (converted to surroundings) - List of dicts with \"name\" and \"description\" - List of Surrounding objects - Surroundings builder - ContextBuilder (other args ignored if used)</p> required <code>events</code> <code>Optional[Union[List[str], List[Dict[str, str]], List[Event]]]</code> <p>Recent events that occurred. Can be: - Simple list of strings - List of dicts with \"event_type\" and \"event_description\" - List of Event objects</p> <code>None</code> <code>knowledge_graph</code> <code>Optional[Union[KnowledgeGraph, Dict]]</code> <p>Optional knowledge graph for NPC memory. Can be: - KnowledgeGraph object - Dict with \"nodes\" and \"edges\"</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object with NPC's action result</p> <p>Raises:</p> Type Description <code>BackendError</code> <p>If the action fails</p>"},{"location":"api/client/#usage-example","title":"Usage Example","text":"<pre><code>from llm_npc import NPCClient, tool\n\n@tool\ndef speak(message: str):\n    \"\"\"Make the NPC speak\"\"\"\n    print(f\"NPC says: {message}\")\n\n# Create client\nclient = NPCClient(\"http://localhost:8080\")\n\n# Check health\nif client.health_check():\n    print(\"Backend is running\")\n\n# Create session\nwith client.session(\"game-123\") as session:\n    # Register tools\n    session.register_tools([speak])\n\n    # Create NPC\n    wizard = session.create_npc(\n        name=\"Merlin\",\n        background=\"A wise old wizard\"\n    )\n\n    # Make NPC act\n    response = wizard.act(\n        surroundings=[\"Tower room\", \"Ancient books\"],\n        events=[\"A visitor arrives\"]\n    )\n\n    print(response.text)\n\n# List all NPCs\nnpcs = client.list_npcs()\nprint(f\"Total NPCs: {npcs['count']}\")\n\n# Delete an NPC\nclient.delete_npc(wizard.npc_id)\n</code></pre>"},{"location":"api/client/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Creating NPCs Guide</li> <li>Decorators API</li> </ul>"},{"location":"api/context/","title":"Context API Reference","text":"<p>The context module provides builders for creating NPC surroundings, events, and knowledge graphs.</p>"},{"location":"api/context/#surroundings","title":"Surroundings","text":""},{"location":"api/context/#llm_npc.context.Surroundings","title":"Surroundings","text":"<pre><code>Surroundings()\n</code></pre> <p>Builder for NPC surroundings.</p> <p>Provides a simple interface for adding surroundings that can be passed directly to NPC.act().</p> Usage <p>surroundings = Surroundings() surroundings.add(\"Tavern\", \"A cozy room with wooden tables\") surroundings.add(\"Stranger\", \"A hooded figure in the corner\")</p>"},{"location":"api/context/#llm_npc.context.Surroundings.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Get surrounding by index.</p>"},{"location":"api/context/#llm_npc.context.Surroundings.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Allow iteration over surroundings.</p>"},{"location":"api/context/#llm_npc.context.Surroundings.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Get number of surroundings.</p>"},{"location":"api/context/#llm_npc.context.Surroundings.add","title":"add","text":"<pre><code>add(name: str, description: str) -&gt; Surroundings\n</code></pre> <p>Add a surrounding object or entity.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the object/entity</p> required <code>description</code> <code>str</code> <p>Description of what it is</p> required <p>Returns:</p> Type Description <code>Surroundings</code> <p>Self for method chaining</p>"},{"location":"api/context/#llm_npc.context.Surroundings.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; List[Dict[str, str]]\n</code></pre> <p>Convert to backend API format (list of dicts).</p>"},{"location":"api/context/#event","title":"Event","text":""},{"location":"api/context/#llm_npc.context.Event","title":"Event","text":"<pre><code>Event(event_type: str, event_description: str)\n</code></pre> <p>Represents a game event.</p> Usage <p>event = Event(\"discovery\", \"You found a hidden passage\")</p>"},{"location":"api/context/#llm_npc.context.Event.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, str]\n</code></pre> <p>Convert to backend API format.</p>"},{"location":"api/context/#knowledgegraph","title":"KnowledgeGraph","text":""},{"location":"api/context/#llm_npc.context.KnowledgeGraph","title":"KnowledgeGraph","text":"<pre><code>KnowledgeGraph()\n</code></pre> <p>Builder for knowledge graphs representing NPC memory and relationships.</p> Usage <p>kg = KnowledgeGraph() kg.add_node(\"player\", type=\"person\", name=\"Hero\") kg.add_node(\"quest\", type=\"quest\", name=\"Save the village\") kg.add_edge(\"player\", \"quest\", relationship=\"active\")</p>"},{"location":"api/context/#llm_npc.context.KnowledgeGraph.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Get total number of nodes and edges.</p>"},{"location":"api/context/#llm_npc.context.KnowledgeGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(source: str, target: str, **data: Any) -&gt; KnowledgeGraph\n</code></pre> <p>Add an edge (relationship) between two nodes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source node ID</p> required <code>target</code> <code>str</code> <p>Target node ID</p> required <code>**data</code> <code>Any</code> <p>Arbitrary data to attach to the edge (e.g., relationship type)</p> <code>{}</code> <p>Returns:</p> Type Description <code>KnowledgeGraph</code> <p>Self for method chaining</p>"},{"location":"api/context/#llm_npc.context.KnowledgeGraph.add_node","title":"add_node","text":"<pre><code>add_node(node_id: str, **data: Any) -&gt; KnowledgeGraph\n</code></pre> <p>Add a node to the knowledge graph.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>Unique identifier for this node</p> required <code>**data</code> <code>Any</code> <p>Arbitrary data to attach to the node</p> <code>{}</code> <p>Returns:</p> Type Description <code>KnowledgeGraph</code> <p>Self for method chaining</p>"},{"location":"api/context/#llm_npc.context.KnowledgeGraph.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, List[Dict[str, Any]]]\n</code></pre> <p>Convert to backend API format.</p>"},{"location":"api/context/#contextbuilder","title":"ContextBuilder","text":""},{"location":"api/context/#llm_npc.context.ContextBuilder","title":"ContextBuilder","text":"<pre><code>ContextBuilder()\n</code></pre> <p>Advanced builder for constructing complete NPC action context.</p> <p>Provides a fluent interface for building complex context including surroundings, events, and knowledge graphs.</p> Usage <p>context = ContextBuilder() context.add_surrounding(\"Room\", \"A dark room\") context.add_event(\"noise\", \"You hear a sound\") context.set_knowledge_graph(kg)</p> <p>response = npc.act(context)</p>"},{"location":"api/context/#llm_npc.context.ContextBuilder.events","title":"events  <code>property</code>","text":"<pre><code>events: List[Event]\n</code></pre> <p>Get the list of events.</p>"},{"location":"api/context/#llm_npc.context.ContextBuilder.knowledge_graph","title":"knowledge_graph  <code>property</code>","text":"<pre><code>knowledge_graph: Union[KnowledgeGraph, None]\n</code></pre> <p>Get the knowledge graph.</p>"},{"location":"api/context/#llm_npc.context.ContextBuilder.surroundings","title":"surroundings  <code>property</code>","text":"<pre><code>surroundings: Surroundings\n</code></pre> <p>Get the surroundings builder.</p>"},{"location":"api/context/#llm_npc.context.ContextBuilder.add_event","title":"add_event","text":"<pre><code>add_event(event_type: str, event_description: str) -&gt; ContextBuilder\n</code></pre> <p>Add a game event.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type/category of the event</p> required <code>event_description</code> <code>str</code> <p>Description of what happened</p> required <p>Returns:</p> Type Description <code>ContextBuilder</code> <p>Self for method chaining</p>"},{"location":"api/context/#llm_npc.context.ContextBuilder.add_surrounding","title":"add_surrounding","text":"<pre><code>add_surrounding(name: str, description: str) -&gt; ContextBuilder\n</code></pre> <p>Add a surrounding object or entity.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the object/entity</p> required <code>description</code> <code>str</code> <p>Description of what it is</p> required <p>Returns:</p> Type Description <code>ContextBuilder</code> <p>Self for method chaining</p>"},{"location":"api/context/#llm_npc.context.ContextBuilder.build","title":"build","text":"<pre><code>build() -&gt; Dict[str, Any]\n</code></pre> <p>Build the complete context as a dict for the backend API.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with surroundings, events, and knowledge_graph keys</p>"},{"location":"api/context/#llm_npc.context.ContextBuilder.set_knowledge_graph","title":"set_knowledge_graph","text":"<pre><code>set_knowledge_graph(knowledge_graph: KnowledgeGraph) -&gt; ContextBuilder\n</code></pre> <p>Set the knowledge graph for this context.</p> <p>Parameters:</p> Name Type Description Default <code>knowledge_graph</code> <code>KnowledgeGraph</code> <p>A KnowledgeGraph instance</p> required <p>Returns:</p> Type Description <code>ContextBuilder</code> <p>Self for method chaining</p>"},{"location":"api/context/#usage-examples","title":"Usage Examples","text":""},{"location":"api/context/#building-surroundings","title":"Building Surroundings","text":"<pre><code>from llm_npc import Surroundings\n\nsurroundings = Surroundings()\nsurroundings.add(\"Forest\", \"A dark, dense forest\")\nsurroundings.add(\"Path\", \"A winding dirt path\")\nsurroundings.add(\"Cottage\", \"A small wooden cottage\")\n\n# Use with NPC\nresponse = npc.act(surroundings)\n\n# Or chain methods\nsurroundings = (Surroundings()\n    .add(\"Forest\", \"A dark forest\")\n    .add(\"Path\", \"A dirt path\")\n    .add(\"Cottage\", \"A wooden cottage\"))\n</code></pre>"},{"location":"api/context/#creating-events","title":"Creating Events","text":"<pre><code>from llm_npc import Event\n\nevents = [\n    Event(\"arrival\", \"You just arrived at the forest\"),\n    Event(\"sound\", \"You hear wolves howling\"),\n    Event(\"discovery\", \"You spot a cottage ahead\")\n]\n\nresponse = npc.act(surroundings, events)\n</code></pre>"},{"location":"api/context/#building-knowledge-graphs","title":"Building Knowledge Graphs","text":"<pre><code>from llm_npc import KnowledgeGraph\n\nkg = KnowledgeGraph()\n\n# Add nodes\nkg.add_node(\"player\", type=\"person\", name=\"Hero\")\nkg.add_node(\"dragon\", type=\"creature\", name=\"Smaug\")\nkg.add_node(\"treasure\", type=\"object\", value=\"immense\")\n\n# Add relationships\nkg.add_edge(\"dragon\", \"treasure\", relationship=\"guards\")\nkg.add_edge(\"player\", \"dragon\", relationship=\"hunting\")\n\n# Use with NPC\nresponse = npc.act(surroundings, events, knowledge_graph=kg)\n\n# Or chain methods\nkg = (KnowledgeGraph()\n    .add_node(\"player\", type=\"person\")\n    .add_node(\"dragon\", type=\"creature\")\n    .add_edge(\"player\", \"dragon\", relationship=\"hunting\"))\n</code></pre>"},{"location":"api/context/#using-context-builder","title":"Using Context Builder","text":"<pre><code>from llm_npc import ContextBuilder, KnowledgeGraph\n\n# Build complete context\ncontext = ContextBuilder()\ncontext.add_surrounding(\"Castle\", \"A grand castle\")\ncontext.add_surrounding(\"King\", \"The king on his throne\")\ncontext.add_event(\"arrival\", \"You were summoned\")\n\n# Optional: add knowledge graph\nkg = KnowledgeGraph()\nkg.add_node(\"king\", disposition=\"pleased\")\ncontext.set_knowledge_graph(kg)\n\n# Use with NPC\nresponse = npc.act(context)\n\n# Or chain all methods\ncontext = (ContextBuilder()\n    .add_surrounding(\"Castle\", \"A grand castle\")\n    .add_event(\"arrival\", \"You were summoned\")\n    .set_knowledge_graph(kg))\n</code></pre>"},{"location":"api/context/#accessing-surroundings","title":"Accessing Surroundings","text":"<pre><code>surroundings = Surroundings()\nsurroundings.add(\"Forest\", \"Dark forest\")\nsurroundings.add(\"Sword\", \"Rusty sword\")\n\n# Get count\nprint(len(surroundings))  # 2\n\n# Iterate\nfor item in surroundings:\n    print(f\"{item.name}: {item.description}\")\n\n# Index access\nfirst = surroundings[0]\nprint(first.name)  # \"Forest\"\n\n# Convert to list\nitems_list = surroundings.to_list()\n</code></pre>"},{"location":"api/context/#knowledge-graph-inspection","title":"Knowledge Graph Inspection","text":"<pre><code>kg = KnowledgeGraph()\nkg.add_node(\"a\", type=\"person\")\nkg.add_node(\"b\", type=\"person\")\nkg.add_edge(\"a\", \"b\", relationship=\"friend\")\n\n# Get size (nodes + edges)\nprint(len(kg))  # 3\n\n# Convert to dict\ngraph_dict = kg.to_dict()\nprint(graph_dict[\"nodes\"])\nprint(graph_dict[\"edges\"])\n</code></pre>"},{"location":"api/context/#see-also","title":"See Also","text":"<ul> <li>Building Context Guide</li> <li>Knowledge Graphs Guide</li> <li>Models API</li> </ul>"},{"location":"api/decorators/","title":"Decorators API Reference","text":"<p>The decorators module provides the <code>@tool</code> decorator for defining game actions.</p>"},{"location":"api/decorators/#tool","title":"tool","text":""},{"location":"api/decorators/#llm_npc.decorators.tool","title":"tool","text":"<pre><code>tool(func: Optional[Callable] = None, *, description: Optional[str] = None) -&gt; Callable\n</code></pre> <p>Decorator to mark a function as a tool that NPCs can use.</p> <p>Automatically extracts: - Tool name from function name - Description from docstring or explicit description parameter - Parameters from function signature with type hints</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>The function to decorate (when used without arguments)</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional explicit description (overrides docstring)</p> <code>None</code> Usage <p>@tool def speak(message: str, target: str = None):     '''Make the NPC speak dialogue'''     pass</p> <p>@tool(description=\"Custom description\") def attack(target: str, damage: int = 10):     pass</p>"},{"location":"api/decorators/#helper-functions","title":"Helper Functions","text":""},{"location":"api/decorators/#llm_npc.decorators.is_tool","title":"is_tool","text":"<pre><code>is_tool(func: Callable) -&gt; bool\n</code></pre> <p>Check if a function is decorated with @tool.</p>"},{"location":"api/decorators/#llm_npc.decorators.get_tool_metadata","title":"get_tool_metadata","text":"<pre><code>get_tool_metadata(func: Callable) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get the tool metadata from a decorated function.</p>"},{"location":"api/decorators/#llm_npc.decorators.tool_to_backend_format","title":"tool_to_backend_format","text":"<pre><code>tool_to_backend_format(func: Callable) -&gt; Dict[str, Any]\n</code></pre> <p>Convert a decorated tool function to backend API format.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>{ \"name\": \"tool_name\", \"description\": \"Tool description\", \"parameters\": {     \"param1\": {\"type\": \"string\", \"description\": \"...\", \"required\": true},     ... }</p> <code>Dict[str, Any]</code> <p>}</p>"},{"location":"api/decorators/#usage-examples","title":"Usage Examples","text":""},{"location":"api/decorators/#basic-tool","title":"Basic Tool","text":"<pre><code>from llm_npc import tool\n\n@tool\ndef speak(message: str):\n    \"\"\"Make the NPC speak dialogue\"\"\"\n    print(f\"NPC says: {message}\")\n</code></pre>"},{"location":"api/decorators/#tool-with-custom-description","title":"Tool with Custom Description","text":"<pre><code>@tool(description=\"Attack a target with a weapon\")\ndef attack(target: str, weapon: str = \"fists\"):\n    \"\"\"\n    Args:\n        target: Enemy to attack\n        weapon: Weapon to use\n    \"\"\"\n    print(f\"Attacked {target} with {weapon}\")\n</code></pre>"},{"location":"api/decorators/#tool-with-multiple-parameters","title":"Tool with Multiple Parameters","text":"<pre><code>@tool\ndef cast_spell(\n    spell_name: str,\n    target: str = None,\n    power: int = 5,\n    verbal: bool = True\n):\n    \"\"\"\n    Cast a magical spell.\n\n    Args:\n        spell_name: Name of the spell\n        target: Optional target\n        power: Spell power level\n        verbal: Whether to speak the incantation\n    \"\"\"\n    if target:\n        print(f\"Cast {spell_name} on {target} (power: {power})\")\n    else:\n        print(f\"Cast {spell_name} (power: {power})\")\n</code></pre>"},{"location":"api/decorators/#inspecting-tool-metadata","title":"Inspecting Tool Metadata","text":"<pre><code>from llm_npc.decorators import is_tool, get_tool_metadata\n\n@tool\ndef my_action(param: str):\n    \"\"\"An example action\"\"\"\n    pass\n\n# Check if it's a tool\nprint(is_tool(my_action))  # True\n\n# Get metadata\nmetadata = get_tool_metadata(my_action)\nprint(metadata[\"name\"])  # \"my_action\"\nprint(metadata[\"description\"])  # \"An example action\"\nprint(metadata[\"parameters\"])  # {'param': {...}}\n</code></pre>"},{"location":"api/decorators/#parameter-type-mapping","title":"Parameter Type Mapping","text":"Python Type Backend Type <code>str</code> <code>\"string\"</code> <code>int</code> <code>\"integer\"</code> <code>float</code> <code>\"float\"</code> <code>bool</code> <code>\"boolean\"</code> <code>Optional[T]</code> Same as <code>T</code> (but not required)"},{"location":"api/decorators/#see-also","title":"See Also","text":"<ul> <li>Defining Tools Guide</li> <li>Client API</li> </ul>"},{"location":"api/exceptions/","title":"Exceptions API Reference","text":"<p>The exceptions module provides custom exception classes for error handling.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>LLMNPCError (base)\n\u251c\u2500\u2500 BackendConnectionError\n\u251c\u2500\u2500 BackendError\n\u251c\u2500\u2500 NPCNotFoundError\n\u251c\u2500\u2500 SessionError\n\u2514\u2500\u2500 ToolRegistrationError\n</code></pre>"},{"location":"api/exceptions/#llmnpcerror","title":"LLMNPCError","text":""},{"location":"api/exceptions/#llm_npc.exceptions.LLMNPCError","title":"LLMNPCError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all LLM NPC SDK errors.</p>"},{"location":"api/exceptions/#backendconnectionerror","title":"BackendConnectionError","text":""},{"location":"api/exceptions/#llm_npc.exceptions.BackendConnectionError","title":"BackendConnectionError","text":"<p>               Bases: <code>LLMNPCError</code></p> <p>Raised when unable to connect to the backend.</p>"},{"location":"api/exceptions/#backenderror","title":"BackendError","text":""},{"location":"api/exceptions/#llm_npc.exceptions.BackendError","title":"BackendError","text":"<pre><code>BackendError(message: str, status_code: int = None)\n</code></pre> <p>               Bases: <code>LLMNPCError</code></p> <p>Raised when the backend returns an error response.</p>"},{"location":"api/exceptions/#npcnotfounderror","title":"NPCNotFoundError","text":""},{"location":"api/exceptions/#llm_npc.exceptions.NPCNotFoundError","title":"NPCNotFoundError","text":"<p>               Bases: <code>LLMNPCError</code></p> <p>Raised when an NPC is not found.</p>"},{"location":"api/exceptions/#sessionerror","title":"SessionError","text":""},{"location":"api/exceptions/#llm_npc.exceptions.SessionError","title":"SessionError","text":"<p>               Bases: <code>LLMNPCError</code></p> <p>Raised when there's an error with session management.</p>"},{"location":"api/exceptions/#toolregistrationerror","title":"ToolRegistrationError","text":""},{"location":"api/exceptions/#llm_npc.exceptions.ToolRegistrationError","title":"ToolRegistrationError","text":"<p>               Bases: <code>LLMNPCError</code></p> <p>Raised when tool registration fails.</p>"},{"location":"api/exceptions/#usage-examples","title":"Usage Examples","text":""},{"location":"api/exceptions/#handling-connection-errors","title":"Handling Connection Errors","text":"<pre><code>from llm_npc import NPCClient\nfrom llm_npc.exceptions import BackendConnectionError\n\nclient = NPCClient(\"http://localhost:8080\")\n\ntry:\n    if not client.health_check():\n        print(\"Backend is not running\")\nexcept BackendConnectionError as e:\n    print(f\"Cannot connect to backend: {e}\")\n    print(\"Make sure the backend server is running\")\n</code></pre>"},{"location":"api/exceptions/#handling-backend-errors","title":"Handling Backend Errors","text":"<pre><code>from llm_npc.exceptions import BackendError\n\ntry:\n    response = npc.act(surroundings, events)\nexcept BackendError as e:\n    print(f\"Backend error: {e}\")\n    if e.status_code:\n        print(f\"HTTP Status Code: {e.status_code}\")\n</code></pre>"},{"location":"api/exceptions/#handling-tool-registration-errors","title":"Handling Tool Registration Errors","text":"<pre><code>from llm_npc.exceptions import ToolRegistrationError\n\ndef not_decorated():\n    \"\"\"This function is missing the @tool decorator\"\"\"\n    pass\n\ntry:\n    session.register_tools([not_decorated])\nexcept ToolRegistrationError as e:\n    print(f\"Tool registration failed: {e}\")\n    # \"Function not_decorated is not decorated with @tool\"\n</code></pre>"},{"location":"api/exceptions/#handling-npc-errors","title":"Handling NPC Errors","text":"<pre><code>from llm_npc.exceptions import NPCNotFoundError\n\ntry:\n    client.delete_npc(\"nonexistent-id\")\nexcept NPCNotFoundError as e:\n    print(f\"NPC not found: {e}\")\n</code></pre>"},{"location":"api/exceptions/#catching-all-sdk-errors","title":"Catching All SDK Errors","text":"<pre><code>from llm_npc.exceptions import LLMNPCError\n\ntry:\n    # Any SDK operation\n    response = npc.act(surroundings)\nexcept LLMNPCError as e:\n    # Catches all SDK exceptions\n    print(f\"SDK error: {e}\")\nexcept Exception as e:\n    # Catches other exceptions (network, etc.)\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api/exceptions/#complete-error-handling-example","title":"Complete Error Handling Example","text":"<pre><code>from llm_npc import NPCClient, tool\nfrom llm_npc.exceptions import (\n    BackendConnectionError,\n    BackendError,\n    ToolRegistrationError,\n    SessionError,\n    LLMNPCError\n)\n\n@tool\ndef speak(message: str):\n    \"\"\"Make NPC speak\"\"\"\n    pass\n\ntry:\n    # Connect to backend\n    client = NPCClient(\"http://localhost:8080\")\n\n    if not client.health_check():\n        raise BackendConnectionError(\"Backend not responding\")\n\n    # Create session and NPC\n    with client.session(\"game\") as session:\n        try:\n            session.register_tools([speak])\n        except ToolRegistrationError as e:\n            print(f\"Tool registration failed: {e}\")\n            raise\n\n        npc = session.create_npc(\"Guard\", \"A city guard\")\n\n        # Make NPC act\n        try:\n            response = npc.act([\"Town square\"], [\"A thief runs past\"])\n            if not response.success:\n                print(f\"NPC action failed: {response.error}\")\n        except BackendError as e:\n            print(f\"Backend error during action: {e}\")\n            if e.status_code == 503:\n                print(\"LLM service unavailable\")\n            elif e.status_code == 504:\n                print(\"LLM timeout\")\n\nexcept BackendConnectionError as e:\n    print(f\"Cannot connect: {e}\")\nexcept SessionError as e:\n    print(f\"Session error: {e}\")\nexcept LLMNPCError as e:\n    print(f\"SDK error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api/exceptions/#see-also","title":"See Also","text":"<ul> <li>Error Handling Guide</li> <li>Client API</li> </ul>"},{"location":"api/models/","title":"Models API Reference","text":"<p>The models module provides typed data classes for working with NPC responses and context.</p>"},{"location":"api/models/#response","title":"Response","text":""},{"location":"api/models/#llm_npc.models.Response","title":"Response  <code>dataclass</code>","text":"<pre><code>Response(success: bool, text: str, rounds: List[Round] = list(), tools_used: List[ToolCall] = list(), raw_data: Dict[str, Any] = dict(), error: Optional[str] = None)\n</code></pre> <p>Represents the response from an NPC action.</p>"},{"location":"api/models/#llm_npc.models.Response.llm_response","title":"llm_response  <code>property</code>","text":"<pre><code>llm_response: str\n</code></pre> <p>Alias for text for compatibility.</p>"},{"location":"api/models/#llm_npc.models.Response.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Response\n</code></pre> <p>Create from backend response.</p>"},{"location":"api/models/#toolcall","title":"ToolCall","text":""},{"location":"api/models/#llm_npc.models.ToolCall","title":"ToolCall  <code>dataclass</code>","text":"<pre><code>ToolCall(tool_name: str, args: Dict[str, Any], success: bool, response: Optional[str] = None, result: Optional[str] = None)\n</code></pre> <p>Represents a tool call made by the NPC.</p>"},{"location":"api/models/#llm_npc.models.ToolCall.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Alias for tool_name for convenience.</p>"},{"location":"api/models/#llm_npc.models.ToolCall.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; ToolCall\n</code></pre> <p>Create from backend response.</p>"},{"location":"api/models/#round","title":"Round","text":""},{"location":"api/models/#llm_npc.models.Round","title":"Round  <code>dataclass</code>","text":"<pre><code>Round(tools_used: List[ToolCall] = list(), raw_data: Dict[str, Any] = dict())\n</code></pre> <p>Represents a single round of NPC inference.</p>"},{"location":"api/models/#llm_npc.models.Round.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Round\n</code></pre> <p>Create from backend response.</p>"},{"location":"api/models/#surrounding","title":"Surrounding","text":""},{"location":"api/models/#llm_npc.models.Surrounding","title":"Surrounding  <code>dataclass</code>","text":"<pre><code>Surrounding(name: str, description: str)\n</code></pre> <p>Represents an object or entity in the NPC's surroundings.</p>"},{"location":"api/models/#llm_npc.models.Surrounding.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, str]\n</code></pre> <p>Convert to backend API format.</p>"},{"location":"api/models/#event","title":"Event","text":""},{"location":"api/models/#llm_npc.models.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event(event_type: str, event_description: str)\n</code></pre> <p>Represents an event that has occurred in the game.</p>"},{"location":"api/models/#llm_npc.models.Event.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, str]\n</code></pre> <p>Convert to backend API format.</p>"},{"location":"api/models/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/#working-with-responses","title":"Working with Responses","text":"<pre><code>response = npc.act(surroundings, events)\n\n# Check success\nif response.success:\n    # Get NPC's thought\n    print(f\"Thought: {response.text}\")\n\n    # Check inference rounds\n    print(f\"Rounds: {len(response.rounds)}\")\n\n    # Get all tools used\n    for tool in response.tools_used:\n        print(f\"Tool: {tool.name}\")\n        print(f\"Args: {tool.args}\")\n        print(f\"Success: {tool.success}\")\nelse:\n    print(f\"Error: {response.error}\")\n</code></pre>"},{"location":"api/models/#creating-typed-surroundings","title":"Creating Typed Surroundings","text":"<pre><code>from llm_npc.models import Surrounding\n\nsurroundings = [\n    Surrounding(\"Forest\", \"A dark forest\"),\n    Surrounding(\"Sword\", \"A rusty sword on the ground\")\n]\n\nresponse = npc.act(surroundings)\n</code></pre>"},{"location":"api/models/#creating-typed-events","title":"Creating Typed Events","text":"<pre><code>from llm_npc.models import Event\n\nevents = [\n    Event(\"arrival\", \"A stranger approaches\"),\n    Event(\"threat\", \"The stranger draws a weapon\")\n]\n\nresponse = npc.act(surroundings, events)\n</code></pre>"},{"location":"api/models/#accessing-tool-calls","title":"Accessing Tool Calls","text":"<pre><code>response = npc.act(surroundings, events)\n\nfor tool_call in response.tools_used:\n    # Access properties\n    tool_name = tool_call.name  # or tool_call.tool_name\n    arguments = tool_call.args\n    succeeded = tool_call.success\n    result = tool_call.result  # or tool_call.response\n\n    # Process based on tool\n    if tool_name == \"speak\":\n        message = arguments.get(\"message\")\n        print(f\"NPC said: {message}\")\n</code></pre>"},{"location":"api/models/#iterating-rounds","title":"Iterating Rounds","text":"<pre><code>response = npc.act(surroundings, events)\n\nfor round_num, round_obj in enumerate(response.rounds, 1):\n    print(f\"Round {round_num}:\")\n\n    for tool in round_obj.tools_used:\n        print(f\"  - {tool.name}: {tool.args}\")\n\n    # Access raw data if needed\n    raw = round_obj.raw_data\n</code></pre>"},{"location":"api/models/#see-also","title":"See Also","text":"<ul> <li>Working with Responses Guide</li> <li>Building Context Guide</li> <li>Context API</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Complete working examples to help you get started with the SDK.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":""},{"location":"examples/#simple-game-example","title":"Simple Game Example","text":"<p>A complete tavern scenario demonstrating:</p> <ul> <li>Defining tools with <code>@tool</code> decorator</li> <li>Creating multiple NPCs</li> <li>Using surroundings and events</li> <li>Knowledge graphs for NPC memory</li> <li>Processing NPC responses</li> </ul> <p>Best for: Understanding the basics and seeing the SDK in action</p>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>All examples are in the <code>examples/</code> directory:</p> <pre><code>cd python-sdk/examples\npython simple_game.py\n</code></pre> <p>Backend Required</p> <p>Make sure the backend is running before executing examples: <pre><code># In repository root\n./backend --http\n</code></pre></p>"},{"location":"examples/#example-patterns","title":"Example Patterns","text":""},{"location":"examples/#quick-start-pattern","title":"Quick Start Pattern","text":"<p>Minimal code to get an NPC working:</p> <pre><code>from llm_npc import NPCClient, tool\n\n@tool\ndef speak(message: str):\n    \"\"\"Speak dialogue\"\"\"\n    pass\n\nclient = NPCClient(\"http://localhost:8080\")\n\nwith client.session(\"game\") as session:\n    session.register_tools([speak])\n    npc = session.create_npc(\"Guard\", \"A city guard\")\n    response = npc.act([\"Town square\"], [\"A stranger approaches\"])\n    print(response.text)\n</code></pre>"},{"location":"examples/#multiple-npcs-pattern","title":"Multiple NPCs Pattern","text":"<p>Managing several NPCs:</p> <pre><code>from llm_npc import NPCClient, tool, Surroundings\n\n@tool\ndef speak(message: str):\n    pass\n\nclient = NPCClient(\"http://localhost:8080\")\n\nwith client.session(\"game\") as session:\n    session.register_tools([speak])\n\n    # Create NPCs\n    guard = session.create_npc(\"Guard\", \"Stern city guard\")\n    merchant = session.create_npc(\"Merchant\", \"Friendly merchant\")\n    thief = session.create_npc(\"Thief\", \"Sneaky thief\")\n\n    # Shared surroundings\n    surroundings = Surroundings()\n    surroundings.add(\"Market\", \"Busy marketplace\")\n\n    # Each NPC responds\n    guard_response = guard.act(surroundings, [\"Watching for trouble\"])\n    merchant_response = merchant.act(surroundings, [\"Selling goods\"])\n    thief_response = thief.act(surroundings, [\"Looking for opportunities\"])\n</code></pre>"},{"location":"examples/#state-management-pattern","title":"State Management Pattern","text":"<p>Tracking NPC actions over time:</p> <pre><code>class GameState:\n    def __init__(self):\n        self.npc_locations = {}\n        self.npc_inventory = {}\n\n    def process_response(self, npc_name, response):\n        \"\"\"Process NPC action and update state\"\"\"\n        for tool in response.tools_used:\n            if tool.name == \"move_to\":\n                self.npc_locations[npc_name] = tool.args[\"location\"]\n            elif tool.name == \"pick_up\":\n                if npc_name not in self.npc_inventory:\n                    self.npc_inventory[npc_name] = []\n                self.npc_inventory[npc_name].append(tool.args[\"item\"])\n\n# Usage\nstate = GameState()\nresponse = npc.act(surroundings)\nstate.process_response(\"Guard\", response)\n</code></pre>"},{"location":"examples/#dynamic-context-pattern","title":"Dynamic Context Pattern","text":"<p>Building context from game state:</p> <pre><code>def build_context(player_location, time_of_day, weather):\n    \"\"\"Build context dynamically\"\"\"\n    from llm_npc import Surroundings, Event\n\n    surroundings = Surroundings()\n    surroundings.add(\"Location\", player_location)\n\n    # Add time-based details\n    if time_of_day == \"night\":\n        surroundings.add(\"Lighting\", \"Dark, moonlit\")\n    else:\n        surroundings.add(\"Lighting\", \"Bright daylight\")\n\n    # Add weather\n    if weather == \"rain\":\n        events = [Event(\"weather\", \"It starts raining heavily\")]\n    else:\n        events = []\n\n    return surroundings, events\n\n# Use\nsurroundings, events = build_context(\"Forest\", \"night\", \"rain\")\nresponse = npc.act(surroundings, events)\n</code></pre>"},{"location":"examples/#error-handling-pattern","title":"Error Handling Pattern","text":"<p>Robust error handling:</p> <pre><code>from llm_npc import NPCClient\nfrom llm_npc.exceptions import BackendError, LLMNPCError\n\ndef safe_npc_act(npc, surroundings, events, max_retries=3):\n    \"\"\"Make NPC act with retry logic\"\"\"\n    for attempt in range(max_retries):\n        try:\n            response = npc.act(surroundings, events)\n            if response.success:\n                return response\n            else:\n                print(f\"Attempt {attempt + 1} failed: {response.error}\")\n        except BackendError as e:\n            if \"timeout\" in str(e).lower() and attempt &lt; max_retries - 1:\n                print(f\"Timeout, retrying... ({attempt + 1}/{max_retries})\")\n                continue\n            raise\n\n    return None\n\n# Usage\nresponse = safe_npc_act(npc, surroundings, events)\nif response:\n    print(response.text)\nelse:\n    print(\"All attempts failed\")\n</code></pre>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>Check the <code>examples/</code> directory for additional examples and patterns. Contributions welcome!</p>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Try modifying the Simple Game Example</li> <li>Check the User Guide for detailed explanations</li> <li>See Best Practices for production tips</li> </ul>"},{"location":"examples/simple-game/","title":"Simple Game Example","text":"<p>This example demonstrates the core features of the SDK through a tavern scenario with suspicious characters.</p>"},{"location":"examples/simple-game/#source-code","title":"Source Code","text":"<p>The complete example is available at <code>examples/simple_game.py</code>.</p>"},{"location":"examples/simple-game/#overview","title":"Overview","text":"<p>The example creates:</p> <ul> <li>A tavern innkeeper NPC</li> <li>A city guard captain NPC</li> <li>Game tools (speak, move, give items)</li> <li>A scenario with a suspicious stranger</li> </ul>"},{"location":"examples/simple-game/#running-the-example","title":"Running the Example","text":"<pre><code># Start the backend\n./backend --http\n\n# Run the example\ncd python-sdk/examples\npython simple_game.py\n</code></pre>"},{"location":"examples/simple-game/#code-walkthrough","title":"Code Walkthrough","text":""},{"location":"examples/simple-game/#1-define-game-tools","title":"1. Define Game Tools","text":"<pre><code>from llm_npc import tool\n\n@tool(description=\"Make the NPC speak dialogue aloud to nearby characters\")\ndef speak(message: str, target: str = None):\n    \"\"\"\n    Args:\n        message: What the NPC should say\n        target: Optional specific character to address\n    \"\"\"\n    print(f\"[SPEAK] {message}\" + (f\" (to {target})\" if target else \"\"))\n\n@tool(description=\"Move the NPC to a different location\")\ndef move_to(location: str):\n    \"\"\"\n    Args:\n        location: The destination location name\n    \"\"\"\n    print(f\"[MOVE] Moving to {location}\")\n\n@tool(description=\"Give an item to a character\")\ndef give_item(item: str, recipient: str):\n    \"\"\"\n    Args:\n        item: The item to give\n        recipient: Who to give the item to\n    \"\"\"\n    print(f\"[GIVE] Giving {item} to {recipient}\")\n</code></pre>"},{"location":"examples/simple-game/#2-initialize-client","title":"2. Initialize Client","text":"<pre><code>from llm_npc import NPCClient\n\nclient = NPCClient(\"http://localhost:8080\")\n\n# Health check\nif not client.health_check():\n    print(\"\u274c Backend is not running!\")\n    return\n\nprint(\"\u2705 Backend is running\")\n</code></pre>"},{"location":"examples/simple-game/#3-create-session-and-register-tools","title":"3. Create Session and Register Tools","text":"<pre><code>with client.session(\"simple-game-example\") as session:\n    # Register tools - SDK automatically converts to backend format\n    session.register_tools([speak, move_to, give_item])\n    print(\"\u2705 Tools registered\")\n</code></pre>"},{"location":"examples/simple-game/#4-create-npcs","title":"4. Create NPCs","text":"<pre><code>    innkeeper = session.create_npc(\n        name=\"Elara the Innkeeper\",\n        background=\"A warm innkeeper who runs 'The Gilded Swan' tavern. \"\n                  \"She knows all the local gossip and helps travelers.\"\n    )\n\n    guard = session.create_npc(\n        name=\"Captain Marcus\",\n        background=\"A veteran city guard captain. Fair but strict, \"\n                  \"and currently tracking a group of thieves.\"\n    )\n\n    print(f\"\u2705 Created: {innkeeper}\")\n    print(f\"\u2705 Created: {guard}\")\n</code></pre>"},{"location":"examples/simple-game/#5-build-context-with-surroundings","title":"5. Build Context with Surroundings","text":"<pre><code>from llm_npc import Surroundings, Event\n\n# Build surroundings with simple builder\nsurroundings = Surroundings()\nsurroundings.add(\"Tavern Common Room\", \n                \"A cozy room with wooden tables, a roaring fireplace, \"\n                \"and the smell of fresh bread. 5 patrons drinking.\")\nsurroundings.add(\"Hooded Stranger\",\n                \"A figure in a dark cloak sits alone in the corner, \"\n                \"watching the door intently. Hasn't touched their drink.\")\nsurroundings.add(\"Captain Marcus\",\n                \"The city guard captain just entered through the front door, \"\n                \"scanning the room.\")\n</code></pre>"},{"location":"examples/simple-game/#6-define-events","title":"6. Define Events","text":"<pre><code># Define events\nevents = [\n    Event(\"new_customer\", \"A hooded stranger entered 10 minutes ago, watching nervously\"),\n    Event(\"guard_arrival\", \"Captain Marcus, the guard captain, just walked in\")\n]\n</code></pre>"},{"location":"examples/simple-game/#7-make-npc-act","title":"7. Make NPC Act","text":"<pre><code># Execute action - SDK handles all the conversion\nresponse = innkeeper.act(surroundings, events)\n\nif response.success:\n    if response.text:\n        print(f\"\ud83d\udcad Thought: {response.text}\")\n\n    print(f\"Inference rounds: {len(response.rounds)}\")\n\n    # Check tools used\n    if response.tools_used:\n        print(\"\ud83d\udee0\ufe0f  Tools used:\")\n        for tool_call in response.tools_used:\n            print(f\"  - {tool_call.name}({tool_call.args})\")\n            if tool_call.response:\n                print(f\"    \u2192 {tool_call.response}\")\n</code></pre>"},{"location":"examples/simple-game/#8-alternative-simple-lists","title":"8. Alternative: Simple Lists","text":"<p>You can also use simple lists for quick prototyping:</p> <pre><code># Can also use simple lists (SDK converts automatically)\nguard_surroundings = [\n    \"The Gilded Swan Tavern - a well-maintained inn\",\n    \"Hooded Figure - suspicious person matching thief description\",\n    \"Elara the innkeeper behind the bar\",\n    \"Several regular customers drinking\"\n]\n\nguard_events = [\n    \"You spotted someone matching the thieves' description\"\n]\n\nresponse = guard.act(guard_surroundings, guard_events)\n</code></pre>"},{"location":"examples/simple-game/#9-using-knowledge-graphs","title":"9. Using Knowledge Graphs","text":"<pre><code>from llm_npc import KnowledgeGraph\n\n# Build a knowledge graph\nkg = KnowledgeGraph()\nkg.add_node(\"stranger_01\", type=\"person\", name=\"Hooded Stranger\", suspicious=True)\nkg.add_node(\"guard_marcus\", type=\"person\", name=\"Captain Marcus\", role=\"guard\")\nkg.add_node(\"theft_incident\", type=\"event\", description=\"Series of thefts\", date=\"past week\")\nkg.add_edge(\"guard_marcus\", \"theft_incident\", relationship=\"investigating\")\nkg.add_edge(\"stranger_01\", \"theft_incident\", relationship=\"possibly_related\")\n\n# New event\nnew_events = [\n    Event(\"confrontation\", \"Captain Marcus approached the hooded stranger's table\")\n]\n\n# NPC with memory context\nresponse = innkeeper.act(surroundings, new_events, knowledge_graph=kg)\n\nif response.success and response.text:\n    print(f\"\ud83d\udcad Response with memory: {response.text}\")\n</code></pre>"},{"location":"examples/simple-game/#expected-output","title":"Expected Output","text":"<pre><code>=== LLM NPC SDK - Simple Game Example ===\n\n1. Checking backend health...\n\u2705 Backend is running\n\n2. Setting up game session...\n\u2705 Tools registered\n\n3. Creating NPCs...\n\u2705 Created: NPC(id=abc-123, name=Elara the Innkeeper)\n\u2705 Created: NPC(id=def-456, name=Captain Marcus)\n\n4. Running scenario: 'Suspicious Stranger at the Inn'\n\n--- Turn 1: Innkeeper's Perspective ---\n\ud83d\udcad Thought: A hooded stranger has been sitting suspiciously in the corner,\nand now Captain Marcus has arrived. This could be trouble. I should stay\nalert and perhaps inform the captain about the stranger's behavior.\n\nInference rounds: 1\n\ud83d\udee0\ufe0f  Tools used:\n  - speak: {'message': \"Captain, there's someone in the corner who's been acting strange.\", 'target': 'Captain Marcus'}\n[SPEAK] Captain, there's someone in the corner who's been acting strange. (to Captain Marcus)\n\n--- Turn 2: Guard's Perspective ---\n\ud83d\udcad Thought: This hooded figure matches the description of the thieves I've\nbeen tracking. I need to approach carefully and question them.\n\n\ud83d\udee0\ufe0f  Tools used:\n  - move_to: {'location': 'Corner table'}\n  - speak: {'message': 'Hold there. I need to ask you some questions.', 'target': 'Hooded Figure'}\n[MOVE] Moving to Corner table\n[SPEAK] Hold there. I need to ask you some questions. (to Hooded Figure)\n\n=== Example Complete ===\n</code></pre>"},{"location":"examples/simple-game/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Simple API: Just a few lines to create intelligent NPCs</li> <li>Type Safety: IDE autocomplete for all methods</li> <li>Flexible Context: Use simple lists or builders</li> <li>Rich Responses: Easy access to NPC thoughts and actions</li> <li>Knowledge Graphs: Give NPCs memory and context</li> </ol>"},{"location":"examples/simple-game/#modifying-the-example","title":"Modifying the Example","text":"<p>Try changing:</p> <ul> <li>Tools: Add <code>attack</code>, <code>hide</code>, <code>search</code> tools</li> <li>Background: Give NPCs different personalities</li> <li>Surroundings: Change the location (forest, castle, dungeon)</li> <li>Events: Create different scenarios</li> <li>Knowledge Graph: Add more relationships and history</li> </ul>"},{"location":"examples/simple-game/#next-steps","title":"Next Steps","text":"<ul> <li>Read the User Guide for detailed explanations</li> <li>Check API Reference for all available methods</li> <li>See Best Practices for production tips</li> </ul>"},{"location":"user-guide/context/","title":"Building Context","text":"<p>NPCs need context to make intelligent decisions. The SDK provides flexible ways to specify what an NPC can see, what events have occurred, and what they know.</p>"},{"location":"user-guide/context/#three-ways-to-provide-context","title":"Three Ways to Provide Context","text":"<ol> <li>Simple lists (quick and easy)</li> <li>Builder classes (structured and readable)</li> <li>Context builder (advanced, complete control)</li> </ol>"},{"location":"user-guide/context/#surroundings","title":"Surroundings","text":"<p>Surroundings describe what the NPC can see or interact with in their environment.</p>"},{"location":"user-guide/context/#method-1-simple-strings","title":"Method 1: Simple Strings","text":"<p>The easiest way - just pass strings:</p> <pre><code>response = npc.act(\n    surroundings=[\n        \"Dark forest\",\n        \"Rusty sword on ground\",\n        \"Wolf growling nearby\"\n    ]\n)\n</code></pre> <p>The SDK automatically converts each string to a surrounding object with the string as both name and description.</p>"},{"location":"user-guide/context/#method-2-dict-format","title":"Method 2: Dict Format","text":"<p>More control with explicit names and descriptions:</p> <pre><code>response = npc.act(\n    surroundings=[\n        {\n            \"name\": \"Forest\",\n            \"description\": \"A dark forest with tall pine trees and thick underbrush\"\n        },\n        {\n            \"name\": \"Sword\",\n            \"description\": \"An old, rusty iron sword lying in the dirt\"\n        },\n        {\n            \"name\": \"Wolf\",\n            \"description\": \"A large grey wolf, teeth bared, growling aggressively\"\n        }\n    ]\n)\n</code></pre>"},{"location":"user-guide/context/#method-3-surroundings-builder-recommended","title":"Method 3: Surroundings Builder (Recommended)","text":"<p>The cleanest approach using the builder:</p> <pre><code>from llm_npc import Surroundings\n\nsurroundings = Surroundings()\nsurroundings.add(\"Forest\", \"A dark forest with tall pine trees\")\nsurroundings.add(\"Sword\", \"An old, rusty iron sword lying in the dirt\")\nsurroundings.add(\"Wolf\", \"A large grey wolf, teeth bared, growling\")\n\nresponse = npc.act(surroundings)\n</code></pre> <p>Benefits:</p> <ul> <li>Method chaining: <code>Surroundings().add(...).add(...)</code></li> <li>Type safety: Better IDE autocomplete</li> <li>Clear structure: Easy to read and maintain</li> </ul>"},{"location":"user-guide/context/#events","title":"Events","text":"<p>Events describe what has happened recently that the NPC should know about.</p>"},{"location":"user-guide/context/#method-1-simple-strings_1","title":"Method 1: Simple Strings","text":"<p>Quick event descriptions:</p> <pre><code>response = npc.act(\n    surroundings=[...],\n    events=[\n        \"The wolf started growling\",\n        \"You heard a branch snap behind you\"\n    ]\n)\n</code></pre>"},{"location":"user-guide/context/#method-2-dict-format_1","title":"Method 2: Dict Format","text":"<p>Structured events with types:</p> <pre><code>response = npc.act(\n    surroundings=[...],\n    events=[\n        {\n            \"event_type\": \"threat_detected\",\n            \"event_description\": \"A wolf appeared and started growling\"\n        },\n        {\n            \"event_type\": \"sound\",\n            \"event_description\": \"A branch snapped behind you\"\n        }\n    ]\n)\n</code></pre>"},{"location":"user-guide/context/#method-3-event-objects","title":"Method 3: Event Objects","text":"<p>Using the <code>Event</code> class:</p> <pre><code>from llm_npc import Event\n\nevents = [\n    Event(\"threat_detected\", \"A wolf appeared and started growling\"),\n    Event(\"sound\", \"A branch snapped behind you\")\n]\n\nresponse = npc.act(surroundings, events)\n</code></pre>"},{"location":"user-guide/context/#complete-context-example","title":"Complete Context Example","text":"<p>Combining surroundings and events:</p> <pre><code>from llm_npc import Surroundings, Event\n\n# Build surroundings\nsurroundings = Surroundings()\nsurroundings.add(\"Tavern\", \"A crowded tavern with wooden tables and a fireplace\")\nsurroundings.add(\"Bartender\", \"A gruff bartender cleaning glasses\")\nsurroundings.add(\"Stranger\", \"A hooded figure in the corner watching you\")\n\n# Define events\nevents = [\n    Event(\"arrival\", \"You just entered the tavern\"),\n    Event(\"observation\", \"The hooded stranger has been watching you for 5 minutes\")\n]\n\n# Make NPC act with full context\nresponse = npc.act(surroundings, events)\n</code></pre>"},{"location":"user-guide/context/#advanced-context-builder","title":"Advanced: Context Builder","text":"<p>For complex scenarios, use <code>ContextBuilder</code>:</p> <pre><code>from llm_npc import ContextBuilder, KnowledgeGraph\n\n# Build complete context\ncontext = ContextBuilder()\n\n# Add surroundings\ncontext.add_surrounding(\"Castle Throne Room\", \"A grand hall with marble floors\")\ncontext.add_surrounding(\"King\", \"An elderly king sitting on an ornate throne\")\ncontext.add_surrounding(\"Guards\", \"Two armored guards flanking the throne\")\n\n# Add events\ncontext.add_event(\"summons\", \"You were summoned by the king\")\ncontext.add_event(\"quest_completed\", \"You completed the dragon quest\")\n\n# Add knowledge graph (optional)\nkg = KnowledgeGraph()\nkg.add_node(\"king\", type=\"person\", disposition=\"grateful\")\nkg.add_node(\"dragon_quest\", type=\"quest\", status=\"completed\")\nkg.add_edge(\"king\", \"dragon_quest\", relationship=\"assigned\")\ncontext.set_knowledge_graph(kg)\n\n# Use the complete context\nresponse = npc.act(context)\n</code></pre> <p>The context builder creates a complete, structured context with surroundings, events, and optional knowledge graph.</p>"},{"location":"user-guide/context/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/context/#1-be-specific","title":"1. Be Specific","text":"<p>Detailed descriptions help NPCs make better decisions:</p> <pre><code># \u274c Vague\nsurroundings.add(\"Room\", \"A room\")\n\n# \u2705 Specific\nsurroundings.add(\"Throne Room\", \n    \"A vast throne room with vaulted ceilings, stained glass windows, \"\n    \"and red carpet leading to an ornate golden throne\")\n</code></pre>"},{"location":"user-guide/context/#2-include-relevant-details","title":"2. Include Relevant Details","text":"<p>Add details that might affect NPC behavior:</p> <pre><code># Characters\nsurroundings.add(\"Guard\", \n    \"A heavily armored guard, hand on sword hilt, watching you suspiciously\")\n\n# Objects\nsurroundings.add(\"Chest\", \n    \"An unlocked wooden chest with the lid slightly ajar, smelling of old leather\")\n\n# Environment\nsurroundings.add(\"Weather\", \n    \"Heavy rain pounding on the windows, thunder rumbling in the distance\")\n</code></pre>"},{"location":"user-guide/context/#3-temporal-events","title":"3. Temporal Events","text":"<p>Events should explain what just happened or what's currently happening:</p> <pre><code>events = [\n    Event(\"action\", \"The guard just drew his sword\"),\n    Event(\"dialogue\", \"The merchant shouted 'Thief!'\"),\n    Event(\"change\", \"The door slammed shut and locked\"),\n]\n</code></pre>"},{"location":"user-guide/context/#4-scope-appropriately","title":"4. Scope Appropriately","text":"<p>Only include what the NPC can perceive:</p> <pre><code># \u2705 Good - NPC can see/hear these\nsurroundings = Surroundings()\nsurroundings.add(\"Market\", \"Busy marketplace with vendor stalls\")\nsurroundings.add(\"Crowd\", \"Dozens of shoppers browsing goods\")\n\n# \u274c Bad - NPC can't know this\nsurroundings.add(\"Secret Plot\", \"The king is secretly planning your arrest\")\n\n# \u2705 Better - observable signs\nsurroundings.add(\"Guards\", \"More guards than usual, watching the crowd closely\")\nevents = [Event(\"observation\", \"Guards seem alert and searching for someone\")]\n</code></pre>"},{"location":"user-guide/context/#5-reusable-context","title":"5. Reusable Context","text":"<p>Build reusable context templates:</p> <pre><code>def create_market_scene():\n    \"\"\"Standard market scene\"\"\"\n    surroundings = Surroundings()\n    surroundings.add(\"Market Square\", \"A busy open-air market\")\n    surroundings.add(\"Vendors\", \"Various vendors selling goods\")\n    surroundings.add(\"Shoppers\", \"Crowd of people shopping\")\n    return surroundings\n\n# Use for multiple NPCs\nmerchant_response = merchant.act(create_market_scene())\nguard_response = guard.act(create_market_scene())\n</code></pre>"},{"location":"user-guide/context/#dynamic-context","title":"Dynamic Context","text":"<p>Update context based on game state:</p> <pre><code>def get_current_scene(time_of_day, weather, npcs_present):\n    surroundings = Surroundings()\n\n    # Base location\n    surroundings.add(\"Town Square\", \"The central square of the town\")\n\n    # Time-based\n    if time_of_day == \"night\":\n        surroundings.add(\"Lighting\", \"Dim light from scattered torches\")\n    else:\n        surroundings.add(\"Lighting\", \"Bright sunlight\")\n\n    # Weather\n    if weather == \"rain\":\n        surroundings.add(\"Weather\", \"Heavy rain, puddles forming\")\n\n    # NPCs\n    for npc_name in npcs_present:\n        surroundings.add(npc_name, f\"{npc_name} is here\")\n\n    return surroundings\n\n# Use dynamic context\nscene = get_current_scene(\"night\", \"rain\", [\"Guard\", \"Merchant\"])\nresponse = npc.act(scene)\n</code></pre>"},{"location":"user-guide/context/#context-limits","title":"Context Limits","text":"<p>Be mindful of context size:</p> <pre><code># \u2705 Good - focused context\nsurroundings = Surroundings()\nsurroundings.add(\"Room\", \"...\")      # 3-4 key items\nsurroundings.add(\"Person\", \"...\")\nsurroundings.add(\"Object\", \"...\")\n\n# \u26a0\ufe0f Too much - may overwhelm the LLM\nsurroundings = Surroundings()\nfor i in range(50):  # Don't do this!\n    surroundings.add(f\"Item {i}\", \"...\")\n</code></pre> <p>Aim for 3-10 key surroundings and 1-5 events per action.</p>"},{"location":"user-guide/context/#iterating-context","title":"Iterating Context","text":"<p>Access surroundings programmatically:</p> <pre><code>surroundings = Surroundings()\nsurroundings.add(\"Forest\", \"Dark forest\")\nsurroundings.add(\"Sword\", \"Rusty sword\")\n\n# Get count\nprint(len(surroundings))  # 2\n\n# Iterate\nfor item in surroundings:\n    print(f\"{item.name}: {item.description}\")\n\n# Index access\nfirst = surroundings[0]\nprint(first.name)  # \"Forest\"\n</code></pre>"},{"location":"user-guide/context/#next-steps","title":"Next Steps","text":"<ul> <li>Working with Responses - Parse NPC actions and responses</li> <li>Knowledge Graphs - Give NPCs long-term memory</li> <li>API Reference: Context - Full context API documentation</li> </ul>"},{"location":"user-guide/knowledge-graphs/","title":"Knowledge Graphs","text":"<p>Knowledge graphs give NPCs persistent memory and understanding of relationships between entities. They help NPCs remember past events, understand social connections, and make context-aware decisions.</p>"},{"location":"user-guide/knowledge-graphs/#what-is-a-knowledge-graph","title":"What is a Knowledge Graph?","text":"<p>A knowledge graph consists of:</p> <ul> <li>Nodes: Entities (people, places, objects, events, concepts)</li> <li>Edges: Relationships between nodes</li> </ul> <p>Think of it as the NPC's memory and understanding of the world.</p>"},{"location":"user-guide/knowledge-graphs/#creating-a-knowledge-graph","title":"Creating a Knowledge Graph","text":"<pre><code>from llm_npc import KnowledgeGraph\n\nkg = KnowledgeGraph()\n\n# Add nodes (entities)\nkg.add_node(\"player\", type=\"person\", name=\"Hero\", reputation=\"good\")\nkg.add_node(\"king\", type=\"person\", name=\"King Aldric\", disposition=\"neutral\")\nkg.add_node(\"quest_01\", type=\"quest\", name=\"Slay the dragon\", status=\"active\")\n\n# Add edges (relationships)\nkg.add_edge(\"player\", \"king\", relationship=\"serves\")\nkg.add_edge(\"player\", \"quest_01\", relationship=\"accepted\")\nkg.add_edge(\"king\", \"quest_01\", relationship=\"assigned\")\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#using-with-npcs","title":"Using with NPCs","text":"<p>Pass the knowledge graph when NPCs act:</p> <pre><code>response = npc.act(\n    surroundings=[\"Throne room\", \"King Aldric on throne\"],\n    events=[\"You returned from the quest\"],\n    knowledge_graph=kg\n)\n</code></pre> <p>The NPC now has context about the relationships and can reason about them.</p>"},{"location":"user-guide/knowledge-graphs/#node-structure","title":"Node Structure","text":"<p>Nodes have an ID and arbitrary data:</p> <pre><code>kg.add_node(\n    \"npc_merchant_01\",           # Unique ID\n    type=\"person\",                # Data fields (arbitrary)\n    name=\"Tobias the Merchant\",\n    occupation=\"merchant\",\n    location=\"Market Square\",\n    trust_level=\"medium\",\n    owes_money=True\n)\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#common-node-types","title":"Common Node Types","text":"<pre><code># People\nkg.add_node(\"char_001\", type=\"person\", name=\"Alice\", role=\"guard\")\n\n# Places\nkg.add_node(\"loc_tavern\", type=\"location\", name=\"The Gilded Swan\", area=\"downtown\")\n\n# Objects\nkg.add_node(\"item_sword\", type=\"object\", name=\"Legendary Sword\", rarity=\"epic\")\n\n# Events\nkg.add_node(\"evt_battle\", type=\"event\", name=\"Battle of  Crossroads\", date=\"3 days ago\")\n\n# Quests\nkg.add_node(\"quest_dragon\", type=\"quest\", name=\"Slay Dragon\", status=\"active\")\n\n# Concepts\nkg.add_node(\"faction_guild\", type=\"faction\", name=\"Thieves Guild\", alignment=\"chaotic\")\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#edge-structure","title":"Edge Structure","text":"<p>Edges connect two nodes with a relationship:</p> <pre><code>kg.add_edge(\n    \"player\",              # Source node ID\n    \"merchant\",            # Target node ID\n    relationship=\"trusts\", # Relationship type\n    strength=\"high\",       # Additional data (optional)\n    since=\"3 weeks ago\"\n)\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#common-relationships","title":"Common Relationships","text":"<pre><code># Social relationships\nkg.add_edge(\"char_a\", \"char_b\", relationship=\"friend\")\nkg.add_edge(\"char_a\", \"char_b\", relationship=\"enemy\")\nkg.add_edge(\"child\", \"parent\", relationship=\"child_of\")\nkg.add_edge(\"servant\", \"master\", relationship=\"serves\")\n\n# Location relationships\nkg.add_edge(\"person\", \"location\", relationship=\"lives_in\")\nkg.add_edge(\"person\", \"location\", relationship=\"visited\")\n\n# Ownership\nkg.add_edge(\"person\", \"item\", relationship=\"owns\")\nkg.add_edge(\"person\", \"item\", relationship=\"wants\")\n\n# Quest relationships\nkg.add_edge(\"person\", \"quest\", relationship=\"assigned\")\nkg.add_edge(\"person\", \"quest\", relationship=\"completed\")\n\n# Knowledge\nkg.add_edge(\"person\", \"secret\", relationship=\"knows_about\")\nkg.add_edge(\"person\", \"event\", relationship=\"witnessed\")\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#complete-example","title":"Complete Example","text":"<p>Creating a rich NPC memory:</p> <pre><code>from llm_npc import NPCClient, KnowledgeGraph, Surroundings, Event\n\n# Create knowledge graph\nkg = KnowledgeGraph()\n\n# Add characters\nkg.add_node(\"player\", type=\"person\", name=\"Hero\", level=10, reputation=\"hero\")\nkg.add_node(\"king\", type=\"person\", name=\"King Aldric\", disposition=\"grateful\")\nkg.add_node(\"dragon\", type=\"creature\", name=\"Smaug\", status=\"defeated\")\nkg.add_node(\"princess\", type=\"person\", name=\"Princess Elena\", status=\"rescued\")\n\n# Add locations\nkg.add_node(\"castle\", type=\"location\", name=\"Royal Castle\")\nkg.add_node(\"dragon_lair\", type=\"location\", name=\"Dragon's Lair\")\n\n# Add events\nkg.add_node(\"dragon_quest\", type=\"quest\", name=\"Rescue Princess\", status=\"completed\")\nkg.add_node(\"battle\", type=\"event\", name=\"Dragon Battle\", date=\"yesterday\")\n\n# Add relationships\nkg.add_edge(\"player\", \"king\", relationship=\"serves\")\nkg.add_edge(\"player\", \"dragon\", relationship=\"defeated\")\nkg.add_edge(\"player\", \"princess\", relationship=\"rescued\")\nkg.add_edge(\"player\", \"dragon_quest\", relationship=\"completed\")\nkg.add_edge(\"king\", \"dragon_quest\", relationship=\"assigned\")\nkg.add_edge(\"king\", \"princess\", relationship=\"father_of\")\nkg.add_edge(\"dragon\", \"princess\", relationship=\"captured\")\n\n# Use with NPC\nclient = NPCClient(\"http://localhost:8080\")\n\nwith client.session(\"game\") as session:\n    knight = session.create_npc(\n        \"Sir Reginald\",\n        \"A knight who witnessed the hero's victory over the dragon\"\n    )\n\n    surroundings = Surroundings()\n    surroundings.add(\"Throne Room\", \"The king's grand throne room\")\n    surroundings.add(\"Hero\", \"The hero who defeated the dragon\")\n    surroundings.add(\"King\", \"King Aldric looking pleased\")\n\n    events = [\n        Event(\"arrival\", \"The hero has returned from the dragon quest\")\n    ]\n\n    # NPC has context about all relationships\n    response = knight.act(surroundings, events, knowledge_graph=kg)\n\n    print(response.text)\n    # \"The hero has returned victorious! They saved the princess \n    #  and defeated Smaug. The king will surely reward them greatly.\"\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#dynamic-knowledge-graphs","title":"Dynamic Knowledge Graphs","text":"<p>Update knowledge graphs based on game state:</p> <pre><code>class GameKnowledgeGraph:\n    def __init__(self):\n        self.kg = KnowledgeGraph()\n        self._init_world()\n\n    def _init_world(self):\n        \"\"\"Initialize base world knowledge\"\"\"\n        # Add persistent entities\n        self.kg.add_node(\"player\", type=\"person\")\n        self.kg.add_node(\"world\", type=\"meta\")\n\n    def record_meeting(self, person_a: str, person_b: str):\n        \"\"\"Record that two people met\"\"\"\n        self.kg.add_edge(person_a, person_b, \n                        relationship=\"met\",\n                        timestamp=time.time())\n\n    def record_event(self, event_id: str, description: str):\n        \"\"\"Record a world event\"\"\"\n        self.kg.add_node(event_id, \n                        type=\"event\",\n                        description=description,\n                        timestamp=time.time())\n\n    def set_relationship(self, person_a: str, person_b: str, rel_type: str):\n        \"\"\"Set or update a relationship\"\"\"\n        self.kg.add_edge(person_a, person_b, relationship=rel_type)\n\n    def get_graph(self):\n        \"\"\"Get the current knowledge graph\"\"\"\n        return self.kg\n\n# Usage\ngame_kg = GameKnowledgeGraph()\n\n# Record game events\ngame_kg.record_meeting(\"player\", \"merchant\")\ngame_kg.record_event(\"theft_001\", \"Theft at the market\")\ngame_kg.set_relationship(\"player\", \"merchant\", \"trusted_by\")\n\n# Use with NPC\nresponse = npc.act(surroundings, events, knowledge_graph=game_kg.get_graph())\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#knowledge-graph-best-practices","title":"Knowledge Graph Best Practices","text":""},{"location":"user-guide/knowledge-graphs/#1-use-descriptive-ids","title":"1. Use Descriptive IDs","text":"<pre><code># \u2705 Good - clear what it is\nkg.add_node(\"char_merchant_tobias\", type=\"person\", name=\"Tobias\")\nkg.add_node(\"loc_market_square\", type=\"location\", name=\"Market Square\")\n\n# \u274c Bad - unclear\nkg.add_node(\"n1\", type=\"person\", name=\"Tobias\")\nkg.add_node(\"n2\", type=\"location\", name=\"Market Square\")\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#2-keep-relevant-information","title":"2. Keep Relevant Information","text":"<p>Only include what the NPC should know:</p> <pre><code># \u2705 Good - NPC knows about the theft\nkg.add_node(\"theft_01\", type=\"event\", description=\"Theft at market\")\nkg.add_edge(\"player\", \"theft_01\", relationship=\"witnessed\")\n\n# \u274c Bad - NPC shouldn't know player's private thoughts\nkg.add_node(\"player_plan\", type=\"thought\", description=\"Player plans to betray king\")\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#3-update-relationships","title":"3. Update Relationships","text":"<p>Keep relationships current:</p> <pre><code># Initial state\nkg.add_edge(\"guard\", \"player\", relationship=\"suspicious_of\")\n\n# After gaining trust (update or add new edge)\nkg.add_edge(\"guard\", \"player\", relationship=\"trusts\")\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#4-use-meaningful-relationship-types","title":"4. Use Meaningful Relationship Types","text":"<pre><code># \u2705 Good - specific and clear\nkg.add_edge(\"player\", \"sword\", relationship=\"owns\")\nkg.add_edge(\"player\", \"quest\", relationship=\"completed\")\n\n# \u274c Bad - too vague\nkg.add_edge(\"player\", \"sword\", relationship=\"related_to\")\nkg.add_edge(\"player\", \"quest\", relationship=\"has\")\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#5-dont-overload","title":"5. Don't Overload","text":"<p>Keep knowledge graphs focused:</p> <pre><code># \u2705 Good - relevant nodes only (5-15 nodes)\nkg.add_node(\"player\", ...)\nkg.add_node(\"king\", ...)\nkg.add_node(\"quest\", ...)\n\n# \u274c Bad - too much information (50+ nodes)\n# This will overwhelm the LLM\nfor i in range(100):\n    kg.add_node(f\"node_{i}\", ...)\n</code></pre> <p>Aim for 5-20 nodes and 5-30 edges for best results.</p>"},{"location":"user-guide/knowledge-graphs/#knowledge-graph-scope","title":"Knowledge Graph Scope","text":"<p>Different NPCs can have different knowledge graphs:</p> <pre><code># Guard's knowledge\nguard_kg = KnowledgeGraph()\nguard_kg.add_node(\"player\", type=\"person\", reputation=\"suspicious\")\nguard_kg.add_edge(\"player\", \"theft\", relationship=\"suspect\")\n\nguard_response = guard.act([...], knowledge_graph=guard_kg)\n\n# Merchant's knowledge  \nmerchant_kg = KnowledgeGraph()\nmerchant_kg.add_node(\"player\", type=\"person\", reputation=\"good_customer\")\nmerchant_kg.add_edge(\"player\", \"merchant\", relationship=\"regular_customer\")\n\nmerchant_response = merchant.act([...], knowledge_graph=merchant_kg)\n</code></pre> <p>Different NPCs have different perspectives on the same entity (player).</p>"},{"location":"user-guide/knowledge-graphs/#inspecting-knowledge-graphs","title":"Inspecting Knowledge Graphs","text":"<pre><code>kg = KnowledgeGraph()\nkg.add_node(\"a\", type=\"person\")\nkg.add_node(\"b\", type=\"person\")\nkg.add_edge(\"a\", \"b\", relationship=\"friend\")\n\n# Get as dict\ngraph_dict = kg.to_dict()\nprint(graph_dict)\n# {\n#     'nodes': [{'id': 'a', 'data': {'type': 'person'}}, ...],\n#     'edges': [{'source': 'a', 'target': 'b', 'data': {'relationship': 'friend'}}]\n# }\n\n# Get size\nprint(len(kg))  # Total nodes + edges: 3\n</code></pre>"},{"location":"user-guide/knowledge-graphs/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference: Context - Full KnowledgeGraph API</li> <li>Examples - See knowledge graphs in action</li> <li>Best Practices - Advanced patterns and tips</li> </ul>"},{"location":"user-guide/npcs/","title":"Creating NPCs","text":"<p>NPCs (Non-Player Characters) are the core of your game's AI. This guide shows you how to create, manage, and interact with NPCs using the SDK.</p>"},{"location":"user-guide/npcs/#creating-an-npc","title":"Creating an NPC","text":"<p>NPCs are created within a session:</p> <pre><code>from llm_npc import NPCClient\n\nclient = NPCClient(\"http://localhost:8080\")\n\nwith client.session(\"my-game\") as session:\n    npc = session.create_npc(\n        name=\"Elara the Innkeeper\",\n        background=\"A friendly innkeeper who runs The Gilded Swan tavern\"\n    )\n\n    print(npc)  # NPC(id=abc-123, name=Elara the Innkeeper)\n</code></pre>"},{"location":"user-guide/npcs/#parameters","title":"Parameters","text":"<ul> <li><code>name</code> (required): The NPC's name - used for identification</li> <li><code>background</code> (required): Background story that shapes the NPC's personality and behavior</li> </ul>"},{"location":"user-guide/npcs/#the-background-story","title":"The Background Story","text":"<p>The background story is crucial - it tells the NPC who they are and how to behave.</p>"},{"location":"user-guide/npcs/#good-background-examples","title":"Good Background Examples","text":"<pre><code># \u2705 Detailed, defines personality and role\nguard = session.create_npc(\n    name=\"Captain Marcus\",\n    background=\"A veteran city guard captain with 20 years of experience. \"\n               \"He's fair but strict, takes his duty seriously, and has seen \"\n               \"enough trouble to be cautious around suspicious characters. \"\n               \"Currently tracking a group of thieves.\"\n)\n\n# \u2705 Includes relationships and motivations\nmerchant = session.create_npc(\n    name=\"Tobias the Merchant\",\n    background=\"A shrewd merchant who sells rare goods. He's friendly to \"\n               \"regular customers but will haggle ruthlessly with strangers. \"\n               \"He owes money to the thieves' guild and is nervous about it.\"\n)\n</code></pre>"},{"location":"user-guide/npcs/#background-best-practices","title":"Background Best Practices","text":"<ol> <li>Include personality traits: Friendly, suspicious, greedy, brave, etc.</li> <li>Define their role: What do they do? Why are they here?</li> <li>Add context: Current situation, relationships, goals</li> <li>Be specific: Vague backgrounds lead to generic behavior</li> </ol> <pre><code># \u274c Too vague\nnpc = session.create_npc(\n    name=\"Guard\",\n    background=\"A guard\"\n)\n\n# \u2705 Much better\nnpc = session.create_npc(\n    name=\"Guard Thompson\",\n    background=\"A young castle guard on his first week of duty. \"\n               \"Eager to prove himself but nervous about making mistakes. \"\n               \"Takes orders from Captain Marcus.\"\n)\n</code></pre>"},{"location":"user-guide/npcs/#making-npcs-act","title":"Making NPCs Act","text":"<p>Once created, make NPCs respond to situations with <code>.act()</code>:</p> <pre><code>response = npc.act(\n    surroundings=[\"Town square\", \"Market stalls\", \"Fountain\"],\n    events=[\"A thief just stole from a vendor\"]\n)\n\nif response.success:\n    print(response.text)\n    for tool in response.tools_used:\n        print(f\"Action: {tool.name}\")\n</code></pre> <p>See Building Context for details on surroundings and events.</p>"},{"location":"user-guide/npcs/#multiple-npcs","title":"Multiple NPCs","text":"<p>Create as many NPCs as needed:</p> <pre><code>with client.session(\"my-game\") as session:\n    session.register_tools([speak, move_to])\n\n    # Create multiple NPCs\n    innkeeper = session.create_npc(\n        name=\"Elara\",\n        background=\"Friendly innkeeper\"\n    )\n\n    guard = session.create_npc(\n        name=\"Marcus\",\n        background=\"Strict guard captain\"\n    )\n\n    thief = session.create_npc(\n        name=\"Shadow\",\n        background=\"Stealthy thief\"\n    )\n\n    # Each NPC acts independently\n    innkeeper_response = innkeeper.act([...])\n    guard_response = guard.act([...])\n    thief_response = thief.act([...])\n</code></pre>"},{"location":"user-guide/npcs/#npc-properties","title":"NPC Properties","text":"<p>Each NPC object has these properties:</p> <pre><code>npc = session.create_npc(\"Test\", \"Background\")\n\nprint(npc.npc_id)      # Backend ID: \"abc-123\"\nprint(npc.name)        # \"Test\"\nprint(npc.background)  # \"Background\"\nprint(npc.session)     # Session object\nprint(npc.client)      # NPCClient object\n</code></pre>"},{"location":"user-guide/npcs/#managing-npcs","title":"Managing NPCs","text":""},{"location":"user-guide/npcs/#list-all-npcs","title":"List All NPCs","text":"<pre><code>all_npcs = client.list_npcs()\nprint(f\"Total NPCs: {all_npcs['count']}\")\n\nfor npc_id, info in all_npcs['npcs'].items():\n    print(f\"- {info['name']} ({npc_id})\")\n</code></pre>"},{"location":"user-guide/npcs/#delete-an-npc","title":"Delete an NPC","text":"<pre><code># Delete by ID\nclient.delete_npc(npc.npc_id)\n\n# Or pass the ID directly\nclient.delete_npc(\"abc-123\")\n</code></pre> <p>Deletion is Permanent</p> <p>Deleted NPCs cannot be recovered. They're removed from the backend immediately.</p>"},{"location":"user-guide/npcs/#advanced-npc-patterns","title":"Advanced NPC Patterns","text":""},{"location":"user-guide/npcs/#npc-with-rich-context","title":"NPC with Rich Context","text":"<p>Combine NPCs with knowledge graphs for persistent memory:</p> <pre><code>from llm_npc import KnowledgeGraph\n\n# Create knowledge graph\nkg = KnowledgeGraph()\nkg.add_node(\"player\", type=\"person\", name=\"Hero\", trust=\"high\")\nkg.add_node(\"quest_01\", type=\"quest\", status=\"active\")\nkg.add_edge(\"player\", \"quest_01\", relationship=\"accepted\")\n\n# NPC remembers this context\nresponse = npc.act(\n    surroundings=[\"Castle throne room\", \"The king\"],\n    events=[\"You returned from the quest\"],\n    knowledge_graph=kg\n)\n</code></pre> <p>See Knowledge Graphs for more details.</p>"},{"location":"user-guide/npcs/#contextual-npcs","title":"Contextual NPCs","text":"<p>Same NPC, different contexts:</p> <pre><code>guard = session.create_npc(\n    name=\"Guard\",\n    background=\"City guard on patrol\"\n)\n\n# Daytime patrol\nday_response = guard.act(\n    surroundings=[\"Busy market\", \"Many shoppers\"],\n    events=[\"Everything seems peaceful\"]\n)\n\n# Nighttime patrol\nnight_response = guard.act(\n    surroundings=[\"Dark alley\", \"Suspicious figure\"],\n    events=[\"You hear breaking glass\"]\n)\n</code></pre>"},{"location":"user-guide/npcs/#npcs-with-persistent-state","title":"NPCs with Persistent State","text":"<p>Use scratchpad tools to give NPCs persistent memory across actions:</p> <pre><code>@tool\ndef remember(key: str, value: str):\n    \"\"\"\n    Store something in memory.\n\n    Args:\n        key: What to remember\n        value: The information\n    \"\"\"\n    # Backend handles persistent storage\n    pass\n\n@tool\ndef recall(key: str):\n    \"\"\"\n    Recall something from memory.\n\n    Args:\n        key: What to recall\n    \"\"\"\n    # Backend retrieves stored information\n    pass\n\nsession.register_tools([remember, recall])\nnpc = session.create_npc(\"Memory NPC\", \"An NPC with memory\")\n\n# First interaction\nresponse1 = npc.act([\"You meet someone\", \"They say their name is Alice\"])\n# NPC might use: remember(\"met_person\", \"Alice\")\n\n# Later interaction\nresponse2 = npc.act([\"You see the same person again\"])\n# NPC might use: recall(\"met_person\") and remember meeting Alice\n</code></pre>"},{"location":"user-guide/npcs/#error-handling","title":"Error Handling","text":"<p>Handle NPC-related errors:</p> <pre><code>from llm_npc.exceptions import BackendError, NPCNotFoundError\n\ntry:\n    npc = session.create_npc(\"Test\", \"Background\")\nexcept BackendError as e:\n    print(f\"Failed to create NPC: {e}\")\n    if e.status_code:\n        print(f\"HTTP Status: {e.status_code}\")\n\ntry:\n    client.delete_npc(\"nonexistent-id\")\nexcept NPCNotFoundError:\n    print(\"NPC not found\")\n</code></pre>"},{"location":"user-guide/npcs/#session-management","title":"Session Management","text":"<p>NPCs belong to sessions. When using context managers, cleanup is automatic:</p> <pre><code># \u2705 Recommended: Context manager\nwith client.session(\"game-123\") as session:\n    npc = session.create_npc(\"Test\", \"Background\")\n    # Use npc...\n# Session automatically closed\n\n# \u26a0\ufe0f Manual management (less common)\nsession = client.session(\"game-123\")\nnpc = session.create_npc(\"Test\", \"Background\")\n# Remember to clean up manually if needed\n</code></pre>"},{"location":"user-guide/npcs/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/npcs/#1-descriptive-names","title":"1. Descriptive Names","text":"<p>Use descriptive names that help identify NPCs:</p> <pre><code># \u2705 Good\ncaptain = session.create_npc(\"Captain Sarah Chen\", \"...\")\nmerchant = session.create_npc(\"Old Man Jenkins\", \"...\")\n\n# \u274c Bad\nnpc1 = session.create_npc(\"NPC1\", \"...\")\nchar = session.create_npc(\"Character\", \"...\")\n</code></pre>"},{"location":"user-guide/npcs/#2-detailed-backgrounds","title":"2. Detailed Backgrounds","text":"<p>More detail = better NPC behavior:</p> <pre><code>wizard = session.create_npc(\n    name=\"Aldrin the Wise\",\n    background=\"An elderly wizard who served as the king's advisor for 40 years. \"\n               \"He's knowledgeable about ancient magic and history, speaks slowly \"\n               \"and deliberately, and has a habit of quoting old proverbs. \"\n               \"Recently retired and now runs a magic shop in the capital. \"\n               \"He's patient with beginners but won't tolerate disrespect for magic.\"\n)\n</code></pre>"},{"location":"user-guide/npcs/#3-consistent-tool-sets","title":"3. Consistent Tool Sets","text":"<p>All NPCs in a session share the same tools, so design tools that make sense for all NPCs:</p> <pre><code># Register general-purpose tools\nsession.register_tools([\n    speak,           # Everyone can talk\n    move_to,         # Everyone can move\n    pick_up,         # Everyone can pick things up\n    use_item,        # Everyone can use items\n])\n\n# Then create NPCs with different personalities\nguard = session.create_npc(\"Guard\", \"Strict and dutiful\")\nthief = session.create_npc(\"Thief\", \"Sneaky and opportunistic\")\n\n# They use the same tools differently based on their backgrounds\n</code></pre>"},{"location":"user-guide/npcs/#4-store-npc-references","title":"4. Store NPC References","text":"<p>Keep references to NPCs you'll reuse:</p> <pre><code>class GameNPCs:\n    def __init__(self, session):\n        self.innkeeper = session.create_npc(\"Elara\", \"...\")\n        self.guard = session.create_npc(\"Marcus\", \"...\")\n        self.merchant = session.create_npc(\"Tobias\", \"...\")\n\nwith client.session(\"game\") as session:\n    npcs = GameNPCs(session)\n\n    # Easy to reference later\n    response = npcs.innkeeper.act([...])\n    response = npcs.guard.act([...])\n</code></pre>"},{"location":"user-guide/npcs/#next-steps","title":"Next Steps","text":"<ul> <li>Building Context - Learn how to provide rich context to NPCs</li> <li>Working with Responses - Parse and use NPC responses</li> <li>Knowledge Graphs - Give NPCs persistent memory</li> <li>API Reference: Client - Full NPC API documentation</li> </ul>"},{"location":"user-guide/responses/","title":"Working with Responses","text":"<p>Every time an NPC acts, you get a <code>Response</code> object containing the NPC's thoughts, actions, and metadata. This guide shows you how to work with responses effectively.</p>"},{"location":"user-guide/responses/#basic-response-handling","title":"Basic Response Handling","text":"<pre><code>response = npc.act(surroundings, events)\n\nif response.success:\n    print(f\"NPC thought: {response.text}\")\nelse:\n    print(f\"Error: {response.error}\")\n</code></pre>"},{"location":"user-guide/responses/#response-properties","title":"Response Properties","text":""},{"location":"user-guide/responses/#success-bool","title":"<code>success: bool</code>","text":"<p>Indicates whether the action succeeded:</p> <pre><code>if response.success:\n    # Process the response\n    pass\nelse:\n    # Handle error\n    print(f\"Failed: {response.error}\")\n</code></pre>"},{"location":"user-guide/responses/#text-str","title":"<code>text: str</code>","text":"<p>The NPC's response or internal thought:</p> <pre><code>response = npc.act([...])\nprint(response.text)\n# \"I should approach the stranger and ask their business here.\"\n</code></pre> <p>This is the NPC's natural language response - their thoughts, speech, or narration.</p> <p>Alias Available</p> <p><code>response.llm_response</code> is an alias for <code>response.text</code> for compatibility.</p>"},{"location":"user-guide/responses/#tools_used-listtoolcall","title":"<code>tools_used: List[ToolCall]</code>","text":"<p>All tools the NPC used, flattened across all rounds:</p> <pre><code>for tool in response.tools_used:\n    print(f\"Tool: {tool.name}\")\n    print(f\"Args: {tool.args}\")\n    print(f\"Success: {tool.success}\")\n    if tool.result:\n        print(f\"Result: {tool.result}\")\n</code></pre> <p>Example output: <pre><code>Tool: speak\nArgs: {'message': 'Halt! State your business.', 'target': 'Stranger'}\nSuccess: True\nResult: None\n</code></pre></p>"},{"location":"user-guide/responses/#rounds-listround","title":"<code>rounds: List[Round]</code>","text":"<p>Inference rounds if the NPC performed multi-step reasoning:</p> <pre><code>print(f\"Inference rounds: {len(response.rounds)}\")\n\nfor i, round in enumerate(response.rounds, 1):\n    print(f\"\\nRound {i}:\")\n    for tool in round.tools_used:\n        print(f\"  - {tool.name}: {tool.args}\")\n</code></pre> <p>Most NPCs complete in 1 round, but complex reasoning may use multiple rounds.</p>"},{"location":"user-guide/responses/#error-optionalstr","title":"<code>error: Optional[str]</code>","text":"<p>Error message if the action failed:</p> <pre><code>if not response.success:\n    print(f\"Error occurred: {response.error}\")\n    # \"LLM provider unavailable\"\n</code></pre>"},{"location":"user-guide/responses/#raw_data-dict","title":"<code>raw_data: Dict</code>","text":"<p>Raw backend response for advanced use cases:</p> <pre><code>raw = response.raw_data\nprint(raw.keys())\n# dict_keys(['success', 'llm_response', 'rounds', 'npc_id', ...])\n</code></pre>"},{"location":"user-guide/responses/#tool-calls","title":"Tool Calls","text":"<p>Each tool call has these properties:</p> <pre><code>tool_call = response.tools_used[0]\n\ntool_call.name         # Tool name: \"speak\"\ntool_call.tool_name    # Alias for name\ntool_call.args         # Arguments: {\"message\": \"Hello\"}\ntool_call.success      # Whether it succeeded: True\ntool_call.result       # Result/response: \"Success\"\ntool_call.response     # Alias for result\n</code></pre>"},{"location":"user-guide/responses/#checking-specific-tools","title":"Checking Specific Tools","text":"<p>Check if a specific tool was used:</p> <pre><code>response = npc.act([...])\n\n# Check if NPC spoke\nspoke = any(tool.name == \"speak\" for tool in response.tools_used)\nif spoke:\n    print(\"NPC said something\")\n\n# Get all speak tool calls\nspeech_tools = [t for t in response.tools_used if t.name == \"speak\"]\nfor speech in speech_tools:\n    print(f\"Said: {speech.args['message']}\")\n</code></pre>"},{"location":"user-guide/responses/#extracting-tool-arguments","title":"Extracting Tool Arguments","text":"<pre><code>response = npc.act([...])\n\nfor tool in response.tools_used:\n    if tool.name == \"move_to\":\n        destination = tool.args.get(\"location\")\n        print(f\"NPC moved to: {destination}\")\n\n    elif tool.name == \"attack\":\n        target = tool.args.get(\"target\")\n        weapon = tool.args.get(\"weapon\", \"fists\")\n        print(f\"NPC attacked {target} with {weapon}\")\n</code></pre>"},{"location":"user-guide/responses/#multi-round-inference","title":"Multi-Round Inference","text":"<p>Some NPCs may use multiple reasoning rounds:</p> <pre><code>response = npc.act([...])\n\nfor round_num, round in enumerate(response.rounds, 1):\n    print(f\"\\n=== Round {round_num} ===\")\n\n    if round.tools_used:\n        print(\"Tools used:\")\n        for tool in round.tools_used:\n            print(f\"  - {tool.name}: {tool.args}\")\n    else:\n        print(\"No tools used (thinking only)\")\n</code></pre> <p>Example output: <pre><code>=== Round 1 ===\nTools used:\n  - examine: {'object': 'Suspicious Package'}\n\n=== Round 2 ===\nTools used:\n  - alert_guards: {'reason': 'Found explosive device'}\n  - move_to: {'location': 'Safe Distance'}\n</code></pre></p>"},{"location":"user-guide/responses/#response-patterns","title":"Response Patterns","text":""},{"location":"user-guide/responses/#pattern-1-dialogue-npcs","title":"Pattern 1: Dialogue NPCs","text":"<p>NPCs that primarily speak:</p> <pre><code>@tool\ndef speak(message: str, target: str = None):\n    \"\"\"Speak dialogue\"\"\"\n    pass\n\nresponse = npc.act([...])\n\n# Extract all dialogue\nfor tool in response.tools_used:\n    if tool.name == \"speak\":\n        message = tool.args.get(\"message\")\n        target = tool.args.get(\"target\", \"everyone\")\n        print(f\"To {target}: {message}\")\n</code></pre>"},{"location":"user-guide/responses/#pattern-2-action-npcs","title":"Pattern 2: Action NPCs","text":"<p>NPCs that perform physical actions:</p> <pre><code>response = npc.act([...])\n\n# Process different action types\nfor tool in response.tools_used:\n    if tool.name == \"move_to\":\n        # Handle movement\n        update_npc_position(npc, tool.args[\"location\"])\n\n    elif tool.name == \"pick_up\":\n        # Handle item pickup\n        add_to_inventory(npc, tool.args[\"item\"])\n\n    elif tool.name == \"use_item\":\n        # Handle item usage\n        use_item(npc, tool.args[\"item\"])\n</code></pre>"},{"location":"user-guide/responses/#pattern-3-mixed-npcs","title":"Pattern 3: Mixed NPCs","text":"<p>NPCs that think, speak, and act:</p> <pre><code>response = npc.act([...])\n\n# Show thought process\nif response.text:\n    print(f\"\ud83d\udcad {response.text}\")\n\n# Show actions\nif response.tools_used:\n    print(\"Actions:\")\n    for tool in response.tools_used:\n        if tool.name == \"speak\":\n            print(f\"  \ud83d\udde3\ufe0f  {tool.args['message']}\")\n        elif tool.name == \"move_to\":\n            print(f\"  \ud83d\udeb6 Moved to {tool.args['location']}\")\n        else:\n            print(f\"  \ud83d\udee0\ufe0f  {tool.name}: {tool.args}\")\n</code></pre>"},{"location":"user-guide/responses/#error-handling","title":"Error Handling","text":"<p>Handle different error scenarios:</p> <pre><code>from llm_npc.exceptions import BackendError\n\nresponse = npc.act([...])\n\nif not response.success:\n    error_msg = response.error or \"Unknown error\"\n\n    if \"timeout\" in error_msg.lower():\n        print(\"LLM took too long to respond\")\n    elif \"unavailable\" in error_msg.lower():\n        print(\"LLM service is down\")\n    elif \"rate limit\" in error_msg.lower():\n        print(\"Too many requests\")\n    else:\n        print(f\"Error: {error_msg}\")\n</code></pre>"},{"location":"user-guide/responses/#empty-responses","title":"Empty Responses","text":"<p>Sometimes NPCs produce no output:</p> <pre><code>response = npc.act([...])\n\nif response.success:\n    if not response.text and not response.tools_used:\n        print(\"\u26a0\ufe0f  NPC produced no output\")\n        print(\"   This can happen with small models\")\n        print(\"   Try: a larger model, simpler context, or different prompt\")\n    else:\n        # Process response normally\n        pass\n</code></pre>"},{"location":"user-guide/responses/#caching-responses","title":"Caching Responses","text":"<p>Store responses for game state:</p> <pre><code>class NPCHistory:\n    def __init__(self):\n        self.history = []\n\n    def record(self, npc_name: str, response):\n        \"\"\"Record an NPC's action\"\"\"\n        self.history.append({\n            \"npc\": npc_name,\n            \"timestamp\": time.time(),\n            \"thought\": response.text,\n            \"actions\": [\n                {\n                    \"tool\": tool.name,\n                    \"args\": tool.args\n                }\n                for tool in response.tools_used\n            ]\n        })\n\n    def get_last_action(self, npc_name: str):\n        \"\"\"Get NPC's last action\"\"\"\n        for record in reversed(self.history):\n            if record[\"npc\"] == npc_name:\n                return record\n        return None\n\n# Usage\nhistory = NPCHistory()\n\nresponse = npc.act([...])\nhistory.record(\"Guard Captain\", response)\n\n# Later...\nlast = history.get_last_action(\"Guard Captain\")\nprint(f\"Last action: {last['actions']}\")\n</code></pre>"},{"location":"user-guide/responses/#response-validation","title":"Response Validation","text":"<p>Validate response quality:</p> <pre><code>def validate_response(response) -&gt; bool:\n    \"\"\"Check if response is valid and useful\"\"\"\n    if not response.success:\n        return False\n\n    # At least some output\n    if not response.text and not response.tools_used:\n        return False\n\n    # Tools succeeded\n    for tool in response.tools_used:\n        if not tool.success:\n            print(f\"Warning: Tool {tool.name} failed\")\n            return False\n\n    return True\n\nresponse = npc.act([...])\nif validate_response(response):\n    # Process response\n    pass\nelse:\n    # Retry or use fallback\n    pass\n</code></pre>"},{"location":"user-guide/responses/#combining-multiple-npcs","title":"Combining Multiple NPCs","text":"<p>Process responses from multiple NPCs:</p> <pre><code>def process_scene(npcs, shared_surroundings, shared_events):\n    \"\"\"Process a scene with multiple NPCs\"\"\"\n    responses = {}\n\n    for npc_name, npc in npcs.items():\n        response = npc.act(shared_surroundings, shared_events)\n        responses[npc_name] = response\n\n    # Compile all dialogue\n    all_dialogue = []\n    for npc_name, response in responses.items():\n        for tool in response.tools_used:\n            if tool.name == \"speak\":\n                all_dialogue.append({\n                    \"speaker\": npc_name,\n                    \"message\": tool.args[\"message\"]\n                })\n\n    return all_dialogue\n\n# Usage\nnpcs = {\n    \"Guard\": guard_npc,\n    \"Merchant\": merchant_npc,\n    \"Thief\": thief_npc\n}\n\ndialogue = process_scene(npcs, surroundings, events)\nfor line in dialogue:\n    print(f\"{line['speaker']}: {line['message']}\")\n</code></pre>"},{"location":"user-guide/responses/#next-steps","title":"Next Steps","text":"<ul> <li>Knowledge Graphs - Give NPCs persistent memory</li> <li>Examples - See complete working examples</li> <li>API Reference: Models - Full Response API documentation</li> </ul>"},{"location":"user-guide/tools/","title":"Defining Tools","text":"<p>Tools are game-specific actions that NPCs can perform. The SDK makes it easy to define tools using the <code>@tool</code> decorator, which automatically extracts metadata from your Python functions.</p>"},{"location":"user-guide/tools/#basic-tool-definition","title":"Basic Tool Definition","text":"<p>The simplest way to define a tool:</p> <pre><code>from llm_npc import tool\n\n@tool\ndef speak(message: str):\n    \"\"\"Make the NPC speak dialogue\"\"\"\n    print(f\"NPC says: {message}\")\n</code></pre> <p>The SDK automatically:</p> <ul> <li>Uses the function name as the tool name (<code>speak</code>)</li> <li>Extracts the description from the docstring</li> <li>Determines parameter types from type hints</li> <li>Identifies required vs optional parameters</li> </ul>"},{"location":"user-guide/tools/#custom-description","title":"Custom Description","text":"<p>Override the docstring description:</p> <pre><code>@tool(description=\"Make the NPC speak dialogue aloud to nearby characters\")\ndef speak(message: str):\n    \"\"\"This docstring is ignored when description is provided\"\"\"\n    print(f\"NPC says: {message}\")\n</code></pre>"},{"location":"user-guide/tools/#parameter-types","title":"Parameter Types","text":"<p>The SDK supports multiple parameter types:</p> <pre><code>@tool\ndef attack(\n    target: str,           # String parameter\n    damage: int = 10,      # Integer with default\n    critical: bool = False, # Boolean\n    multiplier: float = 1.0 # Float\n):\n    \"\"\"\n    Attack a target.\n\n    Args:\n        target: Enemy to attack\n        damage: Damage amount\n        critical: Whether it's a critical hit\n        multiplier: Damage multiplier\n    \"\"\"\n    actual_damage = damage * multiplier * (2 if critical else 1)\n    print(f\"Attacked {target} for {actual_damage} damage\")\n</code></pre>"},{"location":"user-guide/tools/#supported-types","title":"Supported Types","text":"Python Type Schema Type Example <code>str</code> <code>string</code> <code>\"hello\"</code> <code>int</code> <code>integer</code> <code>42</code> <code>float</code> <code>float</code> <code>3.14</code> <code>bool</code> <code>boolean</code> <code>True</code>"},{"location":"user-guide/tools/#optional-parameters","title":"Optional Parameters","text":"<p>Parameters with default values are optional:</p> <pre><code>@tool\ndef cast_spell(\n    spell_name: str,        # Required\n    target: str = None,     # Optional\n    power: int = 5          # Optional with default\n):\n    \"\"\"\n    Cast a magical spell.\n\n    Args:\n        spell_name: Name of the spell to cast\n        target: Optional target for the spell\n        power: Spell power level\n    \"\"\"\n    if target:\n        print(f\"Cast {spell_name} on {target} (power: {power})\")\n    else:\n        print(f\"Cast {spell_name} (power: {power})\")\n</code></pre>"},{"location":"user-guide/tools/#documenting-parameters","title":"Documenting Parameters","text":"<p>Use Google-style docstrings to document parameters:</p> <pre><code>@tool\ndef give_item(item: str, recipient: str, quantity: int = 1):\n    \"\"\"\n    Give an item to another character.\n\n    Args:\n        item: Name of the item to give\n        recipient: Character receiving the item\n        quantity: How many to give (default: 1)\n    \"\"\"\n    print(f\"Gave {quantity}x {item} to {recipient}\")\n</code></pre> <p>The SDK parses the docstring and uses the parameter descriptions in the tool schema sent to the backend.</p>"},{"location":"user-guide/tools/#complex-tools","title":"Complex Tools","text":""},{"location":"user-guide/tools/#tool-with-multiple-optional-parameters","title":"Tool with Multiple Optional Parameters","text":"<pre><code>@tool\ndef interact(\n    target: str,\n    action: str = \"talk\",\n    item: str = None,\n    location: str = None\n):\n    \"\"\"\n    Interact with an object or character.\n\n    Args:\n        target: What to interact with\n        action: Type of interaction (talk, use, examine, etc.)\n        item: Optional item to use in the interaction\n        location: Optional specific location for the interaction\n    \"\"\"\n    if item:\n        print(f\"{action} with {target} using {item}\")\n    else:\n        print(f\"{action} with {target}\")\n</code></pre>"},{"location":"user-guide/tools/#tool-that-returns-values","title":"Tool That Returns Values","text":"<p>Tools can return values (though NPCs just see success/failure):</p> <pre><code>@tool\ndef search_container(container: str):\n    \"\"\"\n    Search a container for items.\n\n    Args:\n        container: Container to search\n    \"\"\"\n    # In a real game, this would check actual container contents\n    items = [\"gold coins\", \"health potion\"]\n    return f\"Found: {', '.join(items)}\"\n</code></pre>"},{"location":"user-guide/tools/#registering-tools","title":"Registering Tools","text":"<p>After defining tools, register them with your session:</p> <pre><code>from llm_npc import NPCClient\n\nclient = NPCClient(\"http://localhost:8080\")\n\nwith client.session(\"game-session\") as session:\n    # Register a list of tool functions\n    session.register_tools([\n        speak,\n        attack,\n        cast_spell,\n        give_item,\n        interact,\n        search_container\n    ])\n\n    # Now create NPCs that can use these tools\n    npc = session.create_npc(\"Wizard\", \"A powerful wizard\")\n</code></pre> <p>Decorator Required</p> <p>All functions passed to <code>register_tools()</code> must be decorated with <code>@tool</code>. Otherwise you'll get a <code>ToolRegistrationError</code>.</p>"},{"location":"user-guide/tools/#tool-best-practices","title":"Tool Best Practices","text":""},{"location":"user-guide/tools/#1-clear-descriptions","title":"1. Clear Descriptions","text":"<p>Write clear, concise descriptions that tell the NPC when to use the tool:</p> <pre><code># \u2705 Good - clear purpose\n@tool(description=\"Speak dialogue when you want to communicate with someone\")\ndef speak(message: str):\n    pass\n\n# \u274c Bad - too vague\n@tool(description=\"A tool for talking\")\ndef speak(message: str):\n    pass\n</code></pre>"},{"location":"user-guide/tools/#2-descriptive-parameter-names","title":"2. Descriptive Parameter Names","text":"<p>Use self-explanatory parameter names:</p> <pre><code># \u2705 Good\n@tool\ndef move_to(destination: str, movement_speed: str = \"walk\"):\n    pass\n\n# \u274c Bad\n@tool\ndef move_to(dest: str, spd: str = \"walk\"):\n    pass\n</code></pre>"},{"location":"user-guide/tools/#3-document-all-parameters","title":"3. Document All Parameters","text":"<p>Always include parameter descriptions in docstrings:</p> <pre><code>@tool\ndef complex_action(target: str, method: str, intensity: int):\n    \"\"\"\n    Perform a complex action.\n\n    Args:\n        target: Who or what to target\n        method: How to perform the action\n        intensity: How intense the action should be (1-10)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/tools/#4-sensible-defaults","title":"4. Sensible Defaults","text":"<p>Provide sensible defaults for optional parameters:</p> <pre><code>@tool\ndef attack(target: str, weapon: str = \"fists\", power: int = 5):\n    \"\"\"\n    Attack a target.\n\n    Args:\n        target: Who to attack\n        weapon: Weapon to use (default: fists for unarmed)\n        power: Attack power (default: 5 for normal attack)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/tools/#5-atomic-actions","title":"5. Atomic Actions","text":"<p>Keep tools focused on single actions:</p> <pre><code># \u2705 Good - single responsibility\n@tool\ndef open_door(door: str):\n    \"\"\"Open a door\"\"\"\n    pass\n\n@tool\ndef walk_through_door(door: str):\n    \"\"\"Walk through a door\"\"\"\n    pass\n\n# \u274c Bad - doing too much\n@tool\ndef open_and_walk_through_door(door: str):\n    \"\"\"Open a door and walk through it\"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/tools/#error-handling","title":"Error Handling","text":"<p>If tool registration fails, you'll get a clear error:</p> <pre><code>from llm_npc.exceptions import ToolRegistrationError\n\ndef not_a_tool():\n    \"\"\"This function isn't decorated\"\"\"\n    pass\n\ntry:\n    session.register_tools([not_a_tool])\nexcept ToolRegistrationError as e:\n    print(f\"Error: {e}\")\n    # Error: Function not_a_tool is not decorated with @tool\n</code></pre>"},{"location":"user-guide/tools/#advanced-inspecting-tool-metadata","title":"Advanced: Inspecting Tool Metadata","text":"<p>You can inspect the metadata extracted from a tool:</p> <pre><code>from llm_npc.decorators import get_tool_metadata, is_tool\n\n@tool\ndef my_tool(param: str):\n    \"\"\"A test tool\"\"\"\n    pass\n\n# Check if it's a tool\nprint(is_tool(my_tool))  # True\n\n# Get metadata\nmetadata = get_tool_metadata(my_tool)\nprint(metadata)\n# {\n#     'name': 'my_tool',\n#     'description': 'A test tool',\n#     'parameters': {\n#         'param': {\n#             'type': 'string',\n#             'description': 'Parameter: param',\n#             'required': True\n#         }\n#     }\n# }\n</code></pre>"},{"location":"user-guide/tools/#next-steps","title":"Next Steps","text":"<ul> <li>Creating NPCs - Learn how to create and manage NPCs</li> <li>Building Context - Provide surroundings and events to NPCs</li> <li>API Reference: Decorators - Full decorator API documentation</li> </ul>"}]}